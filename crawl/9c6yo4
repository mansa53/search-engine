{"url": "https://www.reddit.com/r/learnprogramming/comments/9c6yo4/a_collection_of_projects_for_learning/", "text": "Hi everyone. Recently someone posted a question on here about learning multithreading/concurrency by doing projects. I wrote up a really simple answer, but it got me thinking about different types of projects you could do in order to get better with some of the concepts. I put together this collection not as a definitive set of projects, but more as a list of things I personally find interesting. If you want a truly in-depth look into this area of CS/programming, I would recommend finding a book written by one of the experts (i.e., C++ Concurrency In Action).\n\nThese are split into categories, but I think you can actually skip around if you feel comfortable doing so. Also note that you can just try for a working solution on all of these. I\u2019ve found that professional-grade solutions to these tend to be far and above the more obvious implementations efficiency-wise, so don\u2019t worry too much about it unless you want an added challenge.\n\n# First\n\n1. Implement a simple, thread-safe linked list. Any number of threads should be able to attempt a write/read of the list at any time. There are no restrictions about how you do this, just that it should be safe to use for \\[1..n\\] threads. The simplest way to do this would be to use one mutex per linked list, and anytime a thread wants to use that list it acquires the mutex.\n2. Implement a semaphore. It should have two methods: acquire() and release(). Since semaphores can be used to only allow a certain number of threads to progress at any given time, an initial count should be specified (ex: 10 or 0). If more threads call acquire() than there are available slots, the extra threads will block until a slot does become available. Any thread can call release() to signal that a new slot has just opened up.\n3. Implement a busy-waiting lock (spinlock). It has two methods: lock() and unlock(). It gets its name from the fact that for any thread calling lock(), that thread will loop (spin) while it waits for the lock to become available without ever explicitly yielding to other threads. This way, it always tries to use up its full time slice on the CPU core its running on. The restrictions are as follows: lock() should cause the calling thread to block if another thread owns the lock. unlock() should never succeed if the calling thread does not actually own the lock. You can assume that a thread will never call lock() twice in a row without calling unlock() (this is sometimes called a recursive lock).\n4. Implement an atomic variable. This should only use atomic operations rather than a locking mechanism. It should support three operations: load(), store(), compare\\_exchange(). The load operation performs an atomic load and returns that value. The store operation performs an atomic set of the variable, meaning that if 2 threads call store() at the same time, there is no race condition. Compare\\_exchange is interesting because it is saying \u201cIf the variable is equal to expected, set it to newValue, otherwise fail.\u201d The method\u2019s signature might look something like: *bool compare\\_exchange(var expected, var newValue).* A return value of \u201cfalse\u201d means that the value of the variable was not equal to expected, so it failed to set it to the new value.\n5. Implement a shared lock. It supports 4 methods: lock(), unlock(), shared\\_lock(), shared\\_unlock(). Lock and unlock work the same as the spinlock mentioned above. However, shared\\_lock() has the special property that any number of threads can call this to signal that the lock is occupied. If lock() is called when some number of threads have already called shared\\_lock(), that thread will block until all of those threads have called shared\\_unlock. Likewise, if any thread has called lock() and then another thread calls shared\\_lock(), the second thread will block until unlock() has been called.\n\n# Second\n\n1. Implement a concurrent stack. This should support two operations: push() and pop(). The only restriction is that it must be lockfree, meaning you can use atomic operations, but using something like a mutex to secure access to the stack is not allowed.\n2. Implement a concurrent queue. You can draw inspiration from APIs like boost::lockfree::queue or Java\u2019s ConcurrentLinkedQueue.\n3. Implement an amusement park ride similar to Jurassic Park from Universal Studios. There is one station that dispatches the rides, and \\[1..n\\] cars. With this setup, the station is its own thread and the cars are also their own threads. All car threads start off as parked at the station. Every update, people randomly arrive at the station\u2019s queue. Whenever there are enough people to fill a ride and there is an available car, they are loaded up and the car is sent off. The car then begins its own simulation which lasts for a certain number of seconds before it arrives back at the station. It must then wait for its presence to be acknowledged so that the people inside the recently-arrived car can be unloaded, and the car marked as ready for departure once again.\n\n# Third\n\n1. Implement a concurrent hash map. Note that there are existing concurrent hash maps that are ridiculously fast in the face of a high number of threads accessing the table, so my requirements will attempt to make it more doable. This version can use a mixture of atomic operations and locking and is subject to the following requirements:\n   1. If two threads are writing to different segments of the hash table, they will not block each other.\n   2. If one thread is writing to a segment of the hash table while another is reading from another segment of the hash table, they will not block each other.\n   3. If all threads are performing read-only operations on any segment of the hash table, they should never block each other.\n   4. If two threads write to the same segment at the same time, or one is writing while another is trying to read the same segment, they are allowed to block each other.\n2. Design Conway\u2019s Game of Life using a 10,000 by 10,000 grid. It should be configurable to run with 1+ threads. When there are 2 or more threads, the grid should be sectioned off such that each thread updates a specific region of the board. In this way, synchronization will largely be unnecessary except on the boundaries where one thread\u2019s section crosses over into another thread\u2019s section. When a thread completes one iteration of an update, it should wait until the control thread signals that it\u2019s ok to start the next iteration (this way, all threads are all working on the same time step). This should display a very simple, 2D cell-based grid to show the board as it changes at each update.\n3. Implement a custom job scheduler that runs with 1+ threads, where the number of threads is configurable. With this set up, a \u201cjob\u201d is simply a function to execute. In C this might be a function pointer whereas in C++/Java/Haskell it would be a first-class function object. The job scheduler will have two main methods: submit() and waitForJobList(). submit() is used whenever a thread wants to submit a new list of jobs to be executed on the scheduler\u2019s pool of threads. waitForJobList() is for a thread that has submitted a job list but now wants to wait until that list has completed before it continues its execution. Here are the requirements:\n   1. If there is only 1 thread managed by the job system and it calls waitForJobList(), it should not cause a deadlock. The job scheduler should be smart enough to deal with this situation so that multiple jobs can be running concurrently.\n   2. If there are \\[n\\] threads managed by the job system and all of them call waitForJobList at the same time, this still should not cause a deadlock.\n   3. If a thread that is not managed by the job system calls waitForJobList (i.e., the program\u2019s main thread calls this), the job system should be able to deal with this. It should either cause the external thread to spin until the job list finishes, or it should temporarily convert it to a job worker thread so that it can help execute jobs.\n\nAnd that\u2019s my list! I hope at least one of those sounded interesting to you. If I remember something I left out or someone writes something up in the comments then I\u2019ll add to this list.\n\nFeel free to comment here or send me a PM if you\u2019re starting on one of them and want some clarification or some reading material. I\u2019ll try to dig up whatever I can.", "score": 7, "comments": [{"body": "Thanks a lot for this. Last semester I got into a class about scientific computation and we barely touched problems that actually needed multithread, but I really liked it. Gonna try this asap", "id": "e58lqef", "replies": [{"body": "Best of luck! If you get stuck you can PM me and I'll see if I can help", "id": "e5941im", "replies": []}]}, {"body": "I doubt many people get excited about multithreading or concurrency, but thank you.", "id": "e58kklx", "replies": [{"body": "No problem glad you liked it", "id": "e5941sd", "replies": []}]}], "title": "A Collection Of Projects For Learning Multithreading/Concurrency"}