{"url": "https://www.reddit.com/r/learnprogramming/comments/9b2ozf/philosopher_learning_to_program_seeking_advice_on/", "text": "Hey everybody,\n\nSome days ago I decided to start learning programming. I've had some experience in the past, around 14 years ago while in school, but only got to the part of doing some calculators to assist me on some video games I played back then. Anyway, I asked some friends for advice and some of the suggested I'd start learning some languages like python and c#. One of them also suggested this set of lectures (https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu). \n\nSo far I've been doing quite fine with c#, learning some things here and there and doing small projects which is fine, but I feel I could do a lot better. What I am doing mostly is learning by doing. So whenever I do something, I ask myself what does the code really do and how would the end result change if I were to modify it a lil bit. Whenever I have an issue I look it up online and find different ways to solve the issue. I try to understand first why I have the issue in the first place and then what all of those solutions have in common. \n\nI realized then that I didn't really understand what most of the *words* I used while coding actually meant. I know how to use if-then statements, how to access a database and how to send a string from one window to another one, yet I feel I don't really know ***why*** that works. I mean, I know what kind of *words* I have to place there and I feel like I also know what kind of *words* not to use there, and that's mostly by trial-error'ing my way out of it.\n\nNow this is where I explain why I mentioned I'm a philosopher in the title. I've studied phil at uni and then also finished all my classes for my masters degree. I've specialized lately in analytic philosophy and logic so I like to think that my strengths are critical thinking and solving problems by looking at them logically.  One thing both of these have in common (and I hope programming does too) is that by grasping some basic yet fundamental concepts, everything down the line is somehow easier to grasp, even specialized concepts. For example, if you were to learn a new language and someone mentions two words you don't know in that language but explains to you what their meaning is you'd probably get an idea of how and when to use them. But if that person also mentioned that it's an adjective or an adverb, and you know the meaning of adjective and adverb, then you are more likely to know how not to use them in a sentence. \n\n**Straight to the point and TL;DR:**\n\nSo basically I am asking for the following\n\nFirst, I want to know then is if there is any kind of book or online resource that I can use to learn that. That is, anywhere that explains, for example, whats a class, a constructor, a method, etc. Some of these words are probably not like the other, so I what to know what type of words/concepts there are and how they interact with and within each other.\n\nSecond, is this really a decent strategy at learning programming? I figured that I'd rather learn programming and not just programming languages (if you learn one, you learn the second on? and vice-versa?)\n\nThird and last, if I ever manage to grasp some of the basic concepts, should I stay learning c# or should I move to another language.  \n\nThanks a lot in advance and sorry for the long post.\n\nEdit: thanks for all the replies! im already looking up some of the books you suggested\n\n\n", "score": 29, "comments": [{"body": "I don't know about C#, but Python is a very high level language. It handles a lot of stuff for you. I feel like you might actually have a better time in C++ or Java. In those languages, I find it's more clear what the computer is parsing which is a problem if you're starting with programming (since it's harder to follow), but might be helpful if you're already very good at logic. If there's a tldr version of the intuition as to what computers are doing... it's that everything is a chunk of memory somewhere in the computer, and you're calling up that memory to change it or use it in an operation. Nearly everything that follows is either some way to do that, an abstraction that helps you keep track of what's happening, an algorithm, or some way to store data.\n\n\n\nLook at how you make variables for example: in other languages you have to specify what type a variable is, since each variable takes up a different amount of space in memory (if you allocate 4 bytes and use 8, that's a problem). Look up lectures from a college (I've heard MIT has some good ones) or coursera that mimic the start of a 4 year program because they actually explain why things work like they do (to a degree). Or, get a textbook. That will help more than something that tries to get you able to write code as fast as possible.\n\n\n\n\n\nYou might want to take a more theoretical course as well. Look for something with a name like \"algorithms and data structures\", and make sure your math is up to date. I don't know whether you would have done this already, but if you're coming to programming from a theoretical perspective you'll probably enjoy it, and if you've done it already seeing how those concepts are executed on a computer will help tie things together.\n\n\n\n~~~\n\n\n\n\nEvery example you mentioned is an abstraction to help code in large projects better, which isn't surprising if your foundation is in logic since that's the only non-logic/math you'd run into a this point. Specifically, it's object oriented programming. Basically, instead of dealing with a bunch of variables and making new ones as necessary (which quickly gets out of hand), you deal with classes and objects. A class is a template, which can have functions (methods) and class specific variables. \n\n\n\n\n\nHere is what I mean by *class*: say you have a \"rectangle\" class. The class might have some methods (functions tied to a class, that will only work on that class but only need to be given an object in order to work rather than a bunch of variables), like one that returns area, one that returns perimeter, and a few that return a variable tied to the class (you don't want to give direct access to variables in classes, it's a security problem). It might also have some variables, length and width.\n\n\n\n\nSo now you can create some *objects* based on your class. You can have one called rectangle1, with a length of 2 and a width of 3. You also make another called rectangle2, with a length of 4 and a width of 1. These are different objects, different variables, but they have the same format and have the same functions tied to them. \n\n\n\n\nA *constructor* is what you use to create an instance of a class. You give it whatever variables the class has, or have it set some of them to a default value, and the computer will assign some space in memory for all those variable. \n\n\n\n\nThis is useful, because you don't have to worry about lots and lots of variables (eg you can use rectangle23.length, rather than length23). It makes everything easier to track, and things fit together more intuitively. You could do all of this without object oriented programming, but it makes it much easier as you scale up (and also makes security easier).\n\n\n\n\nIn pseudocode:\n\n\n\n    CLASS Rectangle\n    {\n    //variables:\n    int length;\n    int width;\n\n    //Constructor:\n    Rectangle(int l, int w):\n        length=l;\n        width=w;\n\n    //Functions, aka methods when tied to a class:\n    int area():\n        return length * width;\n\n    perimeter():\n        return 2*length + 2*width;\n\n    getLength():\n        return length;\n\n    getWidth():\n        return width;\n    }\n\nin the main body of your code you would do something like this:\n\n\n    //this creates objects (big variables) called rectangle1 and rectangle2 from the Rectangle template\n    Rectangle rectangle1(1, 2); \n    Rectangle rectangle2(4, 1);\n\n    //this will run the area() function on rectangle1 and give the output, just like if you did area(length, width) but\n    //without having to worry about keeping track of any variables except the object\n    output << \"area of rectangle 1; \" << rectangle1.area();\n\n\n\n\nIt's worth noting that, at least in C++, templates are their own thing so the word shouldn't be used interchangeable with class.", "id": "e505hwh", "replies": [{"body": "Just want to add: OP if you know Platonic Forms, OOP is basically just that. Classes are universals, and instances are... instances!", "id": "e50val7", "replies": [{"body": "And programs are proofs!", "id": "e50x5vm", "replies": []}]}]}, {"body": "Hi \ud83d\udc4b \n\nI got into unix systems administration and automation development following a BA in phil, emphasis on symbolic logic, physics and probability, followed by a taught MA. Your background and mine appear to have a few parallels, so assuming you\u2019re coming from a similar perspective, I\u2019d guess the following applies.\n\nYou\u2019re looking for fundamentals. Logic is the right place to start, but jumping ahead to python is going to be confusing. \n\n- I\u2019d recommend you spend the extra time you have over a month or two of weekends to ground yourself first. Pick up a short introduction to computers that goes over von Neumann architecture. \n\n- Follow that with a guide to how any unix-like kernel and OS works; not to spend very long on it, but just to re-familiarize yourself with what happens when you create a `struct`, allocate memory during runtime, and manipulate low-level data structures. \n\n- Start with learning a little C, and make something tiny (like \u201chello, world!\u201d tiny) but which uses pointer arithmetic and arrays. \n\nIf you spend much more than two or three weeks on any of these three pieces, you\u2019re probably overdoing it.\n\n*Then* learn python. It\u2019ll all make much more sense, and it will be much clearer why it\u2019s built the way it is, what a constructor is doing wrt memory and resources, and what the payoffs in using an interpreted OOP language are.\n\nThe rest is just socket connections, networks, and protocols. Go and play!", "id": "e5001s5", "replies": [{"body": "What are some good resources on Von Neumann architecture? ", "id": "e50qq9t", "replies": []}]}, {"body": "If you really wanna get to the bottom of things I suggest\n\n* [From Nand to Tetris](https://www.coursera.org/learn/build-a-computer), a course on how to build a computer from very simple components.\n* [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html), a university-level book/course on programming that is very good.\n\nI don't really understand what you mean by the \"words\" that you have to place etc., but if you have a specific example or question I'd be happy to answer. Also, keep in mind that there are many different programming languages, and just because one language is a certain way doesn't mean that all programming is like that. What the computer really does is to just do simple caculations, like adding and subtracting, with binary numbers. All this talk about \"access modifiers\" like \"private\", and \"methods\", etc. are just concepts in C#, they don't necessarily make sense in another language.\n", "id": "e5029vc", "replies": []}, {"body": "C# is as good a language as any to learn.\n\n&#x200B;\n\nHere's Microsoft's official C# tutorials: [https://docs.microsoft.com/en-us/dotnet/csharp/index](https://docs.microsoft.com/en-us/dotnet/csharp/index)\n\n&#x200B;\n\nThe definitions you're looking for appear to be listed here: [https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index), although I'm not sure that covers all of them.", "id": "e500qv8", "replies": []}, {"body": "> is this really a decent strategy at learning programming?\n\nYes. This is exactly how one should learn to program.\n\nPersonally I think C# is not a great first programming language since it's very OOP oriented. I think a scripting language such as Python or JavaScript are better since those are less bureaucratic.", "id": "e50j9i8", "replies": []}, {"body": ">I asked some friends for advice and some of the suggested I'd start learning some languages like python and c#.\n\nI don't recommend either of those as beginner languages. C or Javascript would be better starting places.\n\n>What I am doing mostly is learning by doing. So whenever I do something, I ask myself what does the code really do and how would the end result change if I were to modify it a lil bit.\n\nThis is good. Keep doing this. And don't be afraid to actually test your ideas, either. You have obscene amounts of hardware power at your fingertips, and the compiler is not silently judging you for every mistake.\n\n>One thing both of these have in common (and I hope programming does too) is that by grasping some basic yet fundamental concepts, everything down the line is somehow easier to grasp, even specialized concepts.\n\nWell, this is kinda half true.\n\nOn the one hand, a lot of concepts learned in one programming language will tend to carry over to others. It becomes much easier for a person to pick up a new programming language once they've already studied a few and spent some years getting familiar with program logic.\n\nAnd on the other hand, you have to remember that building complex 'concepts' out of simple ones is something you do *within every program.* You start with a relatively small number of building blocks given to you by the language itself, and then you get to define things however *you* want in order to vastly expand the kinds of meanings you can capture concisely.\n\n>First, I want to know then is if there is any kind of book or online resource that I can use to learn that. That is, anywhere that explains, for example, whats a class, a constructor, a method, etc.\n\nI've never really found myself referring to any such monolithic resource. You can search something like 'glossary of programming terms' and get pages like [this,](https://www.computerhope.com/jargon/program.htm) but I don't know how much good that'll do you in the end.\n\nKeep in mind that, even though some words are used across many different programming languages and may have closely parallel meanings in each case, the actual implementations may be different in ways that you have to be aware of when you're using them.\n\n>Some of these words are probably not like the other\n\nWell, some of them may be actual keywords while others are not. For instance, 'class' is a keyword in C++ and Java, while 'constructor' and 'method' are not. Conceptually they all have important meanings, but the compiler will actually let you call something 'method' whereas it will not let you call anything 'class'.\n\n>Second, is this really a decent strategy at learning programming?\n\nWhile it's important to learn these words and the concepts that go with them eventually, at the same time you may find that many of these concepts rely so much on context that you aren't in a position to understand them yet. Don't let that get in your way. If you get hung up on the difference between an 'abstract class' and an 'interface' before you understand what variables are and how to use them, on the basis that you want to know all the terminology before proceeding, that's just going to get in your way.\n\n>if I ever manage to grasp some of the basic concepts, should I stay learning c# or should I move to another language.\n\nFor someone in your position I would have recommended starting with C.", "id": "e50vs4l", "replies": []}, {"body": "The biggest choice you have becoming good in porgramming as a non software developer is strongly vs loosely typed. One of these emphasizes a strict and predictable order, and the other a fast and free lifestyle. Good software developers should understand the place for both. You as a hobbyist get to choose.\n\nYou already mentioned the split, do you explore the freedom of Python or the elegant structure of C#. One is scriptty and free, the other is low... But not so low level you want to crack jokes with systems programs (beware, that's where dragons are...) I have done both, so let me describe them a bit.\n\nPython is great for web dev. It's anazing for data processing. When it comes to science and analysing data, R maybe better in stats design but Python is more complete and general easier to hop in with oit a stats background. For websites you have frameworks like Django but so many more. Physics sims are somewhat common too. You could do games but now let's talk about C#.\n\nIn C#, we now have fairly nice names for most of the things we could do in python but didn't have an explicit name for, certainly not in the code/grammar. This order comes with performance and now you are using a language major game engines support like Unity (and now Godot). More so you have a nice level of control bit can dive deeper in areas like CIL. A major project Harmony has opened up many games and even professional software to this low level hackery. Games like RimWirld use it and easily allow players to mod and extend the game.\n\nWhen you ask whats a good way to learn, I would say play. If it's websites, make some free ones for friends. Gaming, then join a modding community. In all of these, be part of open source, following what others do and then try contributing.\n\nIf you find you enjoy being part of these communities maybe consider learning more languages or ststens. Just being on github... Is like the Facebook of coding... Except the drama is bury so deep it's like a gem when you find it (*cough* DHH... Best comit of all time).\n\ngeneral you can find great communities on Slack and discord, depending on you own interests. Connecting with people in a more direct forum can often get you both better resources for your desires but also direct assistance as challenges arise.", "id": "e52zbgg", "replies": []}], "title": "philosopher learning to program seeking advice on concepts (big post, im sorry in advance)"}