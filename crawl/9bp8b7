{"url": "https://www.reddit.com/r/learnprogramming/comments/9bp8b7/c_google_says_to_avoid_unsigned_integer_types/", "text": "Over the several years of hobby programming with C++ I've always used types like \"unsigned int\" or \"uint32\\_t\" for things like window width and height because neither of those values would/should ever be negative, so it made sense to me.\n\n&#x200B;\n\nThen I read this article ([http://wesmckinney.com/blog/avoid-unsigned-integers/](http://wesmckinney.com/blog/avoid-unsigned-integers/)) and thought, really? \"avoid\" using unsigned int? The article says...\n\n\"In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this.\" -   \nGoogle C++ Style Guide\n\n&#x200B;\n\nHow accurate is this information and do you guys still use unsigned integer types when dealing with a data member that should never be negative?", "score": 1, "comments": [{"body": "I think there's a difference between \"don't use unsigned types to say a number will never be negative\" and \"using unsigned types for a number that should never be negative\".\n\nThe first is saying that you're using unsigned ints to force the number to not be negative.  Use assertions for that, as otherwise it sounds like a terrible idea.  It's not saying to not use unsigned ints for something that won't be negative.", "id": "e54x8bp", "replies": []}, {"body": "C++ involves a lot of accidental compromises. This is one.", "id": "e54qh3f", "replies": [{"body": "Suppose so eh? I had to ask for my own sanity, wanted to make sure I wasn't stuck in the past somehow with a case of \"Ewww you still use unsigned ints?\" heh", "id": "e575qw9", "replies": [{"body": "Yeah, i think uints are still useful for expressing intent, though.", "id": "e579loy", "replies": []}]}]}, {"body": "This is just due to a shitty weak typing system that allows implicit casting. You shouldn't believe this in general, and in general your intuitons are correct. (But not really since languages with shit type systems are far more popular that good, strict ones.)\n\nIn other languages with stricter type systems, you can use types to make guarantees like these since the type checker will reject castings of this sort. In fact, you can use types to guarantee all sorts of interesting non-trivial program properties, but generally a proper algebraic type system is required for this (see Haskell or Scala) or a module system (e.g. Standard ML).\n\nEssentially, the assertion here is a) documentation and b) dynamic type checking that makes up for the weak static type checking. You should also keep in mind that the assertions are a *shitty* solution since they're a dynamic check and, in general, there's no guarantee that it won't fail outside of the test cases you've tried. A type-level guarantee is a mathematical guarantee (up to semantic correctness of the language and correctness of the type checker) of the property you want, in this case, non-negativity. \n\nI really don't know why people are cool with weak type systems.\n\nAlso I'm not so familiar with the world of C-like languages so maybe someone has a more practical alternative for you, but I doubt it. ", "id": "e54rwjg", "replies": []}, {"body": "I would have to agree. You shouldn't be using unsigned types as a way preventing a number from being negative. Bake in proper checks and balances so that you're at least properly notified if the code misbehaves. Unsigned types mask various problems and encourage people to do quirky things in code.", "id": "e54s5s5", "replies": []}, {"body": "It\u2019s far easier to detect an error in a value that shouldn\u2019t be negative if it actually can be negative.\n\nEven for types that conceptually cannot be negative, you often end up subtracting those values from each other - and it\u2019s very easy to end up with a bogus value if you\u2019re using unsigned types.", "id": "e54y0r7", "replies": []}, {"body": "> \"In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this.\" - Google C++ Style Guide\n\nFirst, worth noting - Google C++ Style Guide is discouraged by C++ language creators. It's mostly suited for keeping coding in legacy standards and encourages things which now are deprecated or antipatterns.\n\nStill, this one is true.\n\nThe problem of unsigned types is that using them for something that can not be negative does not make it safer. It actually makes it more error prone or harder to detect in case of bugs. `0u - 1` becomes largest possible unsigned integer value of that type - a huge number, not `-1`. This results in bugs, harder to detect than `-1` instead of `0`. Asserts are generally good, for any invariant-checking purpose - not just integers.\n\nAnother thing: try to make a loop on unsigned integer that goes backward. Note: `i < 0` can not be ever true.\n\nIn C++, overflow on signed integers is undefined behaviour. This allows compiler to optimize expressions such as `x + 1 > x` to `true` and apply other optimizations which rely on the fact that the number will never wrap around. Overflow on unsigned integers has well-defined behaviour which uses modulo arithmetic (the numbers wrap around). This is used in scenarios such as hashing, bit masks etc where number is treated more like a sequence of bits than the number itself. For intense math, signed integers can have better performance.\n\n\nSTL containers use unsigned integers for their `.size()`. This is not really good, but such thing was not easily predictable in the past. And when C++ arrived on 16-bit architectures, limiting the maximum size to 32k instead of 64k because of +/- sign that is never used was considered a potential waste of half memory.", "id": "e55q1ir", "replies": []}], "title": "[C++] Google says to avoid unsigned integer types?"}