{"url": "https://www.reddit.com/r/learnprogramming/comments/9b1m5v/about_long_integers_and_storage/", "text": "I posted this at /r/compsci and the automod removed it. Didn't get any feedback from the admins so I'm trying my luck here.\n\nSo I've been trying my hand with competitive coding and solving past contests. This [editorial](https://discuss.codechef.com/questions/133407/gcdmod-editorial) of this [problem](https://www.codechef.com/AUG18B/problems/GCDMOD) is confusing for me. I basically use C and I am aware it's impossible to store such a huge number of magnitude 10^24 using any standard integer or long datatype. \n\nSo I understand the Euclidean GCD formula, what I don't get are the ways they're storing the number. Can anyone elucidate using examples? Any help would be appreciated!", "score": 1, "comments": [{"body": "The article to which you link gives a few different workarounds to the problem, one of which is using `int_128`. Then other workarounds are more mathematical in nature, but the details are spelled out.\n\nI'm not sure what the difficulty is.", "id": "e4znt8h", "replies": [{"body": "I can't use int_128 in C. I don't completely understand the second approach. In modular exponentiation, does the value A^N + B^N change? ", "id": "e4zotgg", "replies": [{"body": "The gist of it is that gcd(a^(n)+b^(n), a-b) is gcd((a^(n)+b^(n))mod(a-b), a-b). You also need the identity (a + b) mod x = (a (mod x) + b (mod x)) mod x.\n\nThen you have the \"multiply mod\" function to finish it all up.", "id": "e4zrxho", "replies": [{"body": "yeah, so to apply mod over a^n + b^n wouldn't I need to calculate and store it's value? Why is the second identity needed? ", "id": "e5111yr", "replies": [{"body": "Because if the sum of a and b is too big to hold in an int (or whatever type you are using), you can't compute `(a + b) mod x` the obvious way.", "id": "e51qyl1", "replies": [{"body": "what is ``(a+b) % x`` used to calculate now?", "id": "e51s6bc", "replies": [{"body": "Look, if you don't think you'll need it, don't worry about it. But you *might* need to take the modulo of the sum of two very, very big numbers (like, say, numbers raised to the nth power) and *if* that happens then it might come in handy.\n\nThe best way to understand this is to do it. You seem to be trying to resolve all questions before you even get started.", "id": "e51sh30", "replies": [{"body": "okay, I'll try to write some rough code and reply to you. Thanks for helping me out. :D", "id": "e51tr3k", "replies": []}, {"body": "so I read the editorial once again and tried this:\n\n    #include <stdio.h>\n    #include <stdlib.h>\n    #define X 10000000007\n    long long modpow(long long a, long long b, long long m)\n    {\n        long long x = 0, y = a;\n        while (b>0)\n        {\n            if (b&1)\n            {\n                x=(x+y)%m;\n            }\n            y=(y+y)%m;\n            b>>=1;\n        }\n        return x;\n    }\n    long long gcd(long long a, long long b)\n    {\n        if (a==0)\n            return b;\n        return gcd(b%a,a);\n    }\n    \n    int main()\n    {\n        int t;\n        scanf(\"%d\",&t);\n        while(t>0)\n        {\n            long long a,b,n,res;\n            scanf(\"%lld %lld %lld\",&a,&b,&n);\n            if (a==b)\n            {\n                res=(modpow(a,n,X)+modpow(b,n,X))%X;\n            }\n            else\n            {\n                res=(modpow(a,n,a-b)+modpow(b,n,a-b))%(a-b);\n                res=gcd(res,a-b)%X;\n            }\n            printf(\"%lld\\n\",res);\n            t--;\n        }\n        return 0;\n    }\n\nThe examples provided seem to run but it gave wrong answer when I submitted it. Any idea, what is amiss? ", "id": "e55l8yl", "replies": []}]}]}]}]}]}]}]}], "title": "About long integers and storage"}