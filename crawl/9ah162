{"url": "https://www.reddit.com/r/learnprogramming/comments/9ah162/variables_in_x86/", "text": "I'm pretty sure I'm using the wrong terminology here. I'm trying to write some assembly that will compile against this test harness:\n\n    #include <stdio.h>\n    int main(int argc, char **argv) \n    {\n        extern int a;\n        printf(\"%d\\n\", a); \n    }\n\nI've cobbled this together from a StackOverflow answer:\n\n    .globl a\n        .data\n        .align 4\n        .type a, @object\n        .size a, 4\n\n    a:\n        .long 10\n        .text\n\nAnd I can compile just fine (`gcc test.c test.s`) and it prints \"10\" like I expect.\n\nNow I'm trying to do some addition and assign the result to a. (the following code snippet occurs immediately after the previous one).\n\n    mov %eax, 3\n    add %eax, 4\n    mov a, %eax\n\nNow when I compile in run, I'd hope it would print 7, but instead it's printing 10.\n\nSo first question: what are the right words to talk about this so I can Google the issue more effectively?\n\nAnd where is my understanding wrong here? Why doesn't this work?\n\nComplete assembly (test.s):\n\n    .globl a                                                                        \n        .data                                                                       \n        .align 4                                                                    \n        .type a, @object                                                            \n        .size a, 4                                                                  \n                                                                                   \n     a:                                                                              \n         .long 10                                                                    \n         .text                                                                       \n                                                                                 \n                                                                                 \n    movl $3, %eax                                                                   \n    addl $4, %eax                                                                   \n    movl %eax, a   \n\ntest harness (use.c):\n\n    #include <stdio.h>\n    int main()\n    {\n        extern int a;\n        printf(\"%d\\n\", a);\n        return 0;\n    }\n\ncompilation:\n\n    gcc use.c test.s\n\nrunning\n \n    ./a.out\n    > 10", "score": 1, "comments": [{"body": "Check the order of the operands. GAS puts source first and destination last.\n\nEdit: Also, 3 and 4 are memory addresses, not immediates. Immediates have a `$`.\n\nEdit 2: By the way, I would expect your code to segfault with those memory addresses. Are you sure you are running the code? How are you running it?\n", "id": "e4vc66k", "replies": [{"body": "Complete example has been edited in.", "id": "e4vdr6f", "replies": []}]}, {"body": "It should be like this.\n\n    movl $3, %eax\n    addl $4, %eax\n    movl %eax, a\n", "id": "e4vd5vl", "replies": [{"body": "Like /u/Updatebjarni said Syntax for GAS is  \n\n    Instruction Source Destination", "id": "e4vda7b", "replies": []}, {"body": "Hm, it's still printing 10, though. Is there some complicated order of execution to be aware of here?", "id": "e4vdenu", "replies": [{"body": "Can you post your complete code?", "id": "e4vdgt5", "replies": [{"body": "I've edited it into the main post", "id": "e4vdqqj", "replies": [{"body": "You never call your assembly code. It doesn't even have a label to call.\n", "id": "e4vdsnc", "replies": [{"body": "Hm, I think this gives me something to go on. Thanks.", "id": "e4vduz6", "replies": [{"body": "I can say a few more words:\n\n* To clarify, it's your `main()` that starts when your program starts, and any other functions/subroutines have to be called from it. What language each routine or function is written in doesn't matter in that respect.\n* Your routine needs to have a global label to be accessible from outside of your assembly file, just like `a` does.\n* Look up \"calling conventions\" for your platform (i386 GCC) to see how parameters are passed to routines and how the routines pass back the result, and how you're supposed to manipulate the stack. In this case there are no parameters or return values, so you can just stick a `ret` at the end of the assembly routine and do nothing else with the stack.\n* A nice technique is to write some code in C, then compile it with `-S` to produce assembly output, which you can then read to see how the compiler does it. This gives you hints for how to write assembly yourself.\n", "id": "e4ve8rr", "replies": []}]}]}]}]}]}]}], "title": "Variables in x86"}