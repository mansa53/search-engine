{"url": "https://www.reddit.com/r/learnprogramming/comments/9ch4pt/when_is_a_good_time_to_learn_about_algorithms/", "text": "Like the title states when is the best time to learn algorithms? Should you learn about them before programming, during the learning process or after you understand a language fully? ", "score": 1, "comments": [{"body": "When you need to because linear searching arrays becomes too slow. Even in performance sensitive programming like game dev, algorithms and data structures only come into play in a small percentage of the hot path.\n\nMaybe sooner if you're making a database or something that's primary goal is searching. It just depends on what you're building.\n\nUnless you mean something else by algorithms?", "id": "e5aqmrh", "replies": [{"body": "Thanks for the response. This is what I meant \"Computer Algorithms\" such as Heapsort, Quick sort merge sort. ", "id": "e5ar7z8", "replies": [{"body": "Well, like I said, depends on what you're working with. I've been doing game engines for over a decade and have never written any of those algorithms, but I'm sure if you were working on a search engine that would be something you'd do on day 1. Do it when it's clear you need it.", "id": "e5arkuw", "replies": []}]}]}, {"body": "I don't think there's any standard. I would just say, if you're very inexperienced and self-teaching, jump into them when you want to, but be wary of the Bottomless Ocean of Knowledge problem; some programming concepts are built on layers and layers of stuff that it will be assumed you already know, so trying to learn them without the prior buildup of knowledge can tear you several new assholes very quickly and make you feel like a hopeless idiot who will never get it.\n\nWhen that happens, it's advisable to take several steps back and practice some stuff you're a little more familiar with. \n\nThat being said, so much of programming is scattershot in its teaching that you're just gonna have to go by feel sometimes, as far as working out whether you can handle something. For me, a danger sign is if hours of study in and I can't even find or make a simple code prototype of something to play around with. It may mean I'm so lost I don't even know where to begin.", "id": "e5ari8j", "replies": []}, {"body": "The study of algorithms is mathematical, and not tied to any particular language.", "id": "e5aoa4b", "replies": [{"body": "But it is tied to programming. Don Knuth invented his own MIX computer in order to do a mathematical analysis of algorithms. You can not decouple the algorithms from the fact that there is a computer, somewhere, in the story. So studying algorithms before you start programming makes little sense, since you have no intuition of the issues that the computer brings to the story.", "id": "e5bijsf", "replies": [{"body": "Things like Karatsuba multiplication, or the Fast Fourier Transform, don't rely on any particular knowledge of computer architecture or programming to analyze or understand.  Indeed, FFT vastly predates computers, by more than a century.  And the \"programming\" part of Dynamic Programming doesn't apply to computers at all.", "id": "e5bkesm", "replies": [{"body": "Ok, those particular examples.\n\nOf course if someone mentions FFT to a computer scientist you immediately ask \"please discuss cachelines and affinity\". Mathematical complexity theory is only part of the story. That gets even more fun if you do your FFT in distributed memory the way weather modelers do. Mathematicians don't see the problem: you FFT in one direction, then the other, then the third. Actual computational scientists worry that about 1/3 of the computing time goes into stuff that is barely even mathematically expressible.\n\nDynamic Programming: this is often tied to memo'ization, which is a computer issue: in math you can say $f_i$ and as long it's defined that's it. On a computer you have to worry whether that is a function call or an array reference. Like I said, you get extra complications from having a computer in the story.", "id": "e5bl5fo", "replies": [{"body": "So?  Everything you mentioned is an implementation detail, and not related to the core study of the algorithms in question.  And those were just the two examples that came immediately to mind...it's pretty much the same for the study of _any_ algorithm.  If you get down to basics with the lambda calculus and Turing machines, they aren't even discussing \"computers\" in the modern sense...the \"computer\" in Turing's paper was a _human_ working on a sheet of paper.", "id": "e5bob0m", "replies": [{"body": "Those are not implementation details. They are what makes computer science different from math.", "id": "e5by0oo", "replies": []}]}]}]}]}]}], "title": "When is a good time to learn about Algorithms?"}