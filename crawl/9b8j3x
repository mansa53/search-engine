{"url": "https://www.reddit.com/r/learnprogramming/comments/9b8j3x/c_observable_collection_is_not_working_with_async/", "text": "I am having a list and I populate the list with a method using for loop. just a number from 1 - 10. Then I created a list view and populate it with Observable collection by converting the list I get from the method into the observable collection. While executing this program I can able to see the list view populated with numbers.\nbut when I populate the same list with the async method I can't see the list view get populate. I used the breakpoints to check whether the methods are working or not. But the methods are all working fine. even my observable collection get populated. but I can't able see the list view.\n\nMy async program:\n\n    <Page.Resources>\n        <DataTemplate x:DataType=\"data:ListItem\" x:Key=\"ListViewTemplate\">\n            <TextBlock Text=\"{x:Bind Number}\" VerticalAlignment=\"Center\"\n                       Margin=\"10,0,0,0\" Foreground=\"Red\"/>\n        </DataTemplate>\n    </Page.Resources>\n    <Grid>\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"Auto\"/>\n            <RowDefinition Height=\"*\"/>\n        </Grid.RowDefinitions>\n        <StackPanel>\n            <ProgressRing IsActive=\"True\" Width=\"50\" Height=\"50\"\n                          Foreground=\"Red\" Name=\"MyProgress\"/>\n            <TextBlock Text=\"ListItems\" FontSize=\"30\"/>\n        </StackPanel>\n\n        <ListView Grid.Row=\"1\" ItemsSource=\"{x:Bind ListItems}\"\n                  ItemTemplate=\"{StaticResource ListViewTemplate}\">\n            \n        </ListView>\n    </Grid>\n\n    Myclass:\n    public class ListItem\n    {\n        public float Number { get; set; }\n    }\n\n    public class ListManager\n    {\n        public async static Task<List<ListItem>> GetItemsAsync()\n        {\n            var listItems = new List<ListItem>();\n            Rootobject temperatures = await getTemperatureAsync();\n\n            for (int i = 0; i < 3; i++)\n            {\n                listItems.Add(new ListItem() { Number = temperatures.hourly.data[i].temperature });\n            }\n            return listItems;\n        }\n\n        private async static Task<Rootobject> getTemperatureAsync()\n        {\n            HttpClient client = new HttpClient();\n            var jsonData = await client.GetStringAsync(\"https://api.darksky.net/forecast/apikey/13.08,80.27?units=si\");\n            var parsedData = JsonConvert.DeserializeObject<Rootobject>(jsonData);\n            return parsedData;\n        }\n    }\n\n    mainpage.xaml.cs\n    ObservableCollection<ListItem> ListItems;\n        public MainPage()\n        {\n            this.InitializeComponent();\n            ThisMethod().GetAwaiter();\n            /*ObservableCollection<ListItem> items = new ObservableCollection<ListItem>(ListManager.GetItems());\n            ListItems = items;*/\n        }\n\n        private async Task ThisMethod()\n        {\n            MyProgress.Visibility = Visibility.Visible;\n            ObservableCollection<ListItem> items = new ObservableCollection<ListItem>(await ListManager.GetItemsAsync());\n            ListItems = items;\n            MyProgress.Visibility = Visibility.Collapsed;\n        }", "score": 1, "comments": [{"body": "Two comments:\n\n1. `ThisMethod().GetAwaiter()` is not meant to be used by application code. Also, it will return immediately - it doesn't block. You want to use `ThisMethod().Wait()` (but you probably don't *actually* want to use it... see below).\n2. Due to the first issue, I think you're running into timing issues.\n\nThe provide more information on that second point, consider `ThisMethod`. I'm going to rewrite it slightly:\n\n    private async Task ThisMethod()\n    {\n        MyProgress.Visibility = Visibility.Visible;\n        var getItemsTask = ListManager.GetItemsAsync();\n        var items = await getItemsTask;\n\n        // \u2702--------------------------------------\n\n        ObservableCollection<ListItem> items = new ObservableCollection<ListItem>(items);\n        ListItems = items;\n        MyProgress.Visibility = Visibility.Collapsed;\n    }\n\nThe dotted line indicates a preemption point. Whenever you're working with `async` methods, any time you `await`, you're essentially cutting the method into two pieces. Everything before the `await` will run immediately, but the code after the `await` will run at some future time.\n\nSo your constructor calls `ThisMethod`, and `ThisMethod` will run up until the dotted line. At that point, `ThisMethod` will apparently return (returning a Task object that corresponds to the not-yet-executed part of the function), and you'll be back in your constructor, which will run to completion. Note that, by the time your constructor finishes, `ListItems` will not be assigned. \n\nIf you change the `GetAwaiter` to just `Wait`, I believe you'll fix this problem, but then you're not actually gaining any benefit from doing things async. You'd be set up to do things asynchronously, but then I your event thread would blockingly wait for the async operation to complete, and I believe that would cause your GUI to freeze while you're waiting for the network request to complete.\n\nIf you want to see what I mean, stick this line somewhere inside `GetTemperatureAsync`:\n\n    await Task.Delay(10000);\n\nThat will add a 10 second pause when fetching the data, which would be a good simulation of a slow network, and you can see any issues that such slowness might cause for your GUI.\n\n---\n\nIf you do want to do things asynchronously, think about it this way. When you start your application, you don't yet have the data from the remote server. So you want to show your application without any data visible (maybe with a loading indicator, so the user knows that \"no data\" really means \"no data yet\"). You fire off an asynchronous request. At some point much later, the asynchronous request will complete. The code that runs when the asynchronous request completes is no different from the code that you might attach to a button's click event: it needs to update the view in *some* way. That could be done by either directly modifying the controls in the view, or done by modifying some observable property that is bound to some control's property. \n\nSince you've started down the data binding path, what you should probably do is to assign an *empty* `ObservableCollection` to `ListItems` early in the constructor - probably before `InitializeComponent`, perhaps as a field initializer, and possibly marking the field as `readonly`. Then, when the async operation completes, rather than assigning a brand new `ObservableCollection` to that field, you should clear out the existing `ObservableCollection` and add all the new items to it. The binding should notice the changes made to the collection and should update the GUI appropriately.\n\nWell, I say that, but I'm not familiar with `x:Bind`. (I never had a ton of WPF experience, and it's been a while since I have touched it.) I notice that `x:Bind`'s default mode is `OneTime`, not `OneWay`. So by default, the binding will execute at application startup, will bind the empty collection, and then will never run again. You will probably need to change your `x:Bind` mode to `OneWay`. Alternatively, you could switch from `x:Bind` to `Binding`, but that has other implications as well (then you would need to consider the `DataContext`).", "id": "e51farn", "replies": [{"body": "That was helpful :)", "id": "e51p4ak", "replies": []}]}], "title": "C# Observable collection is not working with async method"}