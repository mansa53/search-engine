{"url": "https://www.reddit.com/r/learnprogramming/comments/9atza2/any_tips_on_how_to_solve_problems_and_ask_for/", "text": "Since I began coding to this day, I've had more problems programming than the average CS student. Namely, I've never had the patience to continuously keep digging the same few lines of code trying to find the way to make it work; I often give up after a hour or so and completely deplete my box of ideas on how to solve any given problem, to the point where the vast majority of my CS programming assignments didn't even compile. Also, I have a hard time asking for help, as everyone I ask often ends up starting since the very beginning, when what I need is a solution to the point on the specific problem I'm currently having; or worse, suggest a major rewrite when I've already spent all my mental energy on the current version, when what I really need is a tip on how to modify my current version to make it work. How does a normal person tolerate fixing problems?", "score": 1, "comments": [{"body": "First, programming is always going to be frustrating. Programs must be technically perfect, or else they fail. If you break a single syntax rule, your program will refuse to compile. If your logic is not flawless, your program will produce wrong results. Humans weren't meant to keep all of the details of technically correct pieces of information in their heads all at once, and thus a lot of programming is the neverending, doomed effort to hide details from ourselves until we can reason about things meaningfully. Frustration is part of the job.\n\nThat said, hitting your head over any one problem for over an hour isn't productive. If you don't know what's wrong and don't know what to do about it, you can either start over, try random things, walk away and come back, or ask for help.\n\nOften, asking for help can be very productive, not because the person you're talking to can provide help, but because the act of explaining your question in sufficient detail to receive a reasonable answer is often enough to make the solution apparent. Because of this, professionals have been known to keep small rubber ducks on their desk and explain the problem to the duck until they understand what to do.\n\nAnother idea is to make things smaller again. A big part of programming is reducing big problems to a set of smaller, more tractable problems. You may be solving too much at once. Solve one very small part of the problem, perhaps parsing the input. Stop. Test it. Make sure it compiles and works. Check it into a local repository. You now have one part of the problem solved and can back out to this point later. Now try to iterate over the data or whatever. Stop. Compile. Test. Repeat until solved. Do not write code for 6 hours without bothering to see if the code builds. If you haven't tried to compile for 30 minutes, you've probably done something wrong.", "id": "e4y3e02", "replies": []}, {"body": ">  Namely, I've never had the patience to continuously keep digging the same few lines of code trying to find the way to make it work\n\nSadly, continuously digging the same few lines of code trying to make it work is also known as \"an ordinary day in the life of a software engineer\".\n\nI spent a week debugging a problem and finally succeeded in changing a `>` to a `>=`. I am not joking about this. Forget lines of code, my productivity for that week was 1.2 *bits* of code per day.\n\n> Also, I have a hard time asking for help, as everyone I ask often ends up starting since the very beginning, when what I need is a solution to the point on the specific problem I'm currently having\n\nThere are a couple of reasons why people ask you to start at the beginning. First, quite often you will have dug yourself into an impossible hole and there's no real way to fix your existing code, because it's just a big mess. So the best solution is to start again. Second, by starting again you already know what the bad ideas are and, hopefully, what the good ideas might be and you will probably find that the rewrite goes *a lot* faster.", "id": "e4y3k3a", "replies": [{"body": "> Second, by starting again you already know what the bad ideas are and, hopefully, what the good ideas might be and you will probably find that the rewrite goes a lot faster.\n\nThere's a little big problem with that viewpoint - namely, what to do when you do know what your bad ideas are, but can't find any single potential good idea to fix it. Also, deadlines. When you need help at a time when it's impossible to meet the deadline by rewriting, being told that your whole code is useless is almost a punishment by itself.", "id": "e4y44ij", "replies": [{"body": "If you really have no idea what to do, starting over is hardly an imposition.", "id": "e4y4frm", "replies": []}]}, {"body": "As a very beginner programmer, is it not possible to write a program that checks your code for obvious syntax errors? ", "id": "e4y5nhp", "replies": [{"body": "Sure, but the problem wasn't a syntax error. The problem was a *logic* error.", "id": "e4yh9w5", "replies": []}]}]}, {"body": "Some tips:\n\n1. Try compiling and testing your code very frequently. If the way you code is by coding a bunch, then testing a bunch, you're doing it wrong. Instead, figure out how to split up your task into a bunch of small subtasks. Once that's done, complete one subtask (e.g. write just a few lines of code). Test that change, make sure everything's ok, then repeat.\n2. If you're running out of ideas (e.g. transitioning from productive to unproductive struggle), go ask for help -- either google the error messages, go ask your teacher or a TA, etc... \n3. Alternatively, go take a break. Grab a snack, take a quick walk, work on other homework, take a nap, take a shower... Sometimes, giving your brain time to recharge can be surprisingly helpful in helping you make breakthroughs/obtain insights.\n4. If you're constantly getting feedback that you should start with a major rewrite, I would take that as a red flag: it indicates that you're probably not doing a good job of planning your code/thinking about your overall approach. \n\n    If you just start to code without thinking about the bigger picture, it's very easy to end up painting yourself into a corner -- to implement a bunch of code that's just fundamentally difficult to work with. This can then lead into a negative cycle -- you try and polish some messy code, find that you can't, and end up spinning with no progress. The people you're asking feedback from are probably recognizing this/trying to push you towards taking an approach that requires more work now but pays dividends later down the line.\n\n    Taking the time to plan a high-level approach/taking the time to figure out how to break up your tasks can do a lot to help mitigate this issue. (It's also easier to get feedback this way -- you can ask people what they think about your high-level approach and get a yea or nea sooner rather then later.)\n\n5. Again relatedly, have the courage to recognize that sometimes you just need to throw away a chunk of your code and start over. It's disheartening when this happens, but it's normal and happens to everybody.\n6. When you run into a bug, don't just try a bunch of ideas. Instead, your first step should be to *understand* the bug and figure out why it's happening. Bugs happen when your assumptions about how the code works diverged from reality. Start by figuring out what bad assumptions you made. You can do this by conducting experiments on the code -- try adding printlns, try making strategic changes to see what happens...\n\n    Be sure to be systematic when doing this -- adopt the mindset of a scientist, or a detective. If the problem is particularly gnarly, it may even be worth keeping a log of the experiments you conduct -- open up a text file or grab a notebook or something, and record your hypothesis, your experiment, and the result. Rinse and repeat to narrow down what bad assumption you're making.\n\n    (This can also help with motivation -- you may not be making forward progress on your code, but each experiment you run can help narrow down what the problem is/give you a new piece of information.)\n\n7. Set up ways to make sure you have short iteration cycles. This is why I recommended compiling and testing frequently, why I recommend doing a bunch of experiments and collecting clues when debugging... If you can make the time between action to result as short as possible, you can get that dopamine hit of being successful more rapidly.", "id": "e4y4ch4", "replies": []}, {"body": "> programmers with low tolerance to frustration\n\nThis is kind of not a thing. Programmers figure out some way to deal with the frustration that will happen anyway, or they make bad choices with their code or with their lives, or they find a different profession.\n\n> I've had more problems programming than the average CS student\n\nHave you talked to any of your professors to find out why you might be having more problems? Have you worked with a tutor, who can give you personalized guidance and feedback over time? These people are there to help if you are struggling!\n\n> I've never had the patience to continuously keep digging the same few lines of code trying to find the way to make it work\n\nDo you have patience with other things in your life that you don't enjoy doing? How did you develop that patience?\n\nI recommend to people figuring out career stuff to look at the mundane day-to-day activities someone in that career does. Some of what programmers do is create new code, but the vast majority of what programmers do is figure out why some piece of code isn't working and how to fix it. This includes new code, old code broken by new code, and old code broken by updates to the language, the compiler, the operating system, and so on.\n\n> Also, I have a hard time asking for help\n\nThis hurts you as a student. This will lose you your job as an employee.\n\n> what I need is a solution to the point on the specific problem I'm currently having\n\nNo, that's what you want. If you're getting this response regularly, it's probable that what you need is to start over. Often people will say to start over rather than figure out the specific problem because it will take less time to rewrite it correctly than to untangle your problem, or because they are having trouble understanding what you are expecting your code to do and why. Imagine that someone has put on their shirt inside out, and is asking why the tag is on the outside and how to fix it. It's certainly possible to fix the problem by removing the tag and sewing it to the inside, all while still wearing the shirt. It's much more reasonable to take the shirt off, analyze it to figure out which side the tag is on, and put the shirt on again.\n\nHowever, it's also understandable that sometimes, that analysis process before you start over may not help. That's a good time to ask for help too: you tried and failed, you started over with more analysis, and you're just not sure what to do differently. That is when it is good to ask someone to review your pseudocode or diagrams or whatever you use for planning your code.\n\n> I've already spent all my mental energy on the current version\n\nNo -- you've spent a lot of mental energy on *learning about something that doesn't work*, and that is super valuable! It's just practice. As you do more, you'll get better at figuring out earlier when something is not repairable and has to be scrapped. But scrapping code happens. A good way to minimize this is by keeping your functions single-purpose, your classes well-defined, and so on. Not only is this good for helping to avoid needing to scrap your entire project, it also means you are writing bits of code and maybe even libraries that you will find useful and already working for later projects. However, there is no way to guarantee that a piece of code will not be scrapped. Even a piece of good code. Sometimes you write some awesome perfectly functional thing and it turns out that the original specs from the designers were wrong, or the end users just don't like it, or whatever.", "id": "e4y8tkl", "replies": [{"body": "> This is kind of not a thing. Programmers figure out some way to deal with the frustration that will happen anyway, or they make bad choices with their code or with their lives, or they find a different profession.\n\n> Do you have patience with other things in your life that you don't enjoy doing? How did you develop that patience?\n\nNo, I definitely do not have any patience in any endeavor I'm commended to perform, and after years of searching I'm yet to find anyone able to correct me in that regard. \n\n> Have you talked to any of your professors to find out why you might be having more problems?\n\nPart of the problem back in the day was that I enrolled in all the classes I could, so I had no time for talking with professors because I had to go to the next class ASAP. Same for classmates. Back when I finally could manage to have enough time to contact either, I was about to miss the deadline - hence my refusal to remake my code, because doing so would mean losing the assignment completely.\n\n> This hurts you as a student. This will lose you your job as an employee.\n\nI must admit I've been fired once precisely because of this, and it might have contributed to my stagnation in the job before that one. Being unable to cope with this sort of pressure is something my livelihood literally depends on, and at this rate I'm resigned to be constantly fired and maybe rehired every few months.\n\n> It's much more reasonable to take the shirt off, analyze it to figure out which side the tag is on, and put the shirt on again.\n\nYes it is, and it's more time-consuming as well. Most of the time I can't afford the time to rebuild things the proper way.\n\n> you spent a lot of mental energy on *learning about something that doesn't work*\n\nWhich would be useful, but most of the time I end up with a big pile of things that don't work -- and no way to deduce what will work from the clues from that pile. Everyone I ask on how to deduce solutions from context, simply say they Just Know (and can't teach me how to Just Know).\n\n> A good way to minimize this is by keeping your functions single-purpose, your classes well-defined, and so on.\n\nOften I have to work with an already existing codebase, meaning that if has ill-defined classes, mammoth functions, or a literal black box, I'm out of luck entirely.", "id": "e4yg1ww", "replies": [{"body": "Honestly? This is a lot of excuses. It's up to you to deal with your patience issues, and no one can say the magic word or do one quick trick that makes it fun and easy for you to work through something tedious. You can say it will take less time to fix an issue than to start over if you know about how long it will take to troubleshoot and resolve, which isn't the case if \"most of the time\" that issue is \"a big pile of things that don't work\" and no way to solve. And an existing codebase is exactly the time you *need* to be asking questions.\n\nIt sounds like you have deep issues with patience, [sunk cost](https://en.wikipedia.org/wiki/Sunk_cost), and getting help, and like those issues are causing a deep hardship on your life. A therapist might be the best next step. Therapists can be good at helping you figure out why you have certain patterns in your life, and helping you build better patterns. Your school's health center may offer some number of free therapy sessions, and the issues you are describing are common enough that any school-recommended therapist you go to should have plenty of experience dealing with them. Not every therapist is good, or is a good match, so it is good to try again with someone new if another one doesn't work out.", "id": "e4yia6v", "replies": []}, {"body": "People are giving you advice and suggestions and for each one you are explaining why that's not possible and won't work for you.\n\nYou are not a special, magical snow-flake.\n\nCan't cope with frustration? Figure out how to. Get therapy if you need to or just fucking suck it up and deal with it like everyone else has to.\n\nDon't want to ask for help? Get over it.\n\nTaking too many classes? Try taking fewer classes.\n\nHave a big pile of something that won't work? Start with making a small pile. Make sure it works before you add to the pile. The only way you should ever have a big pile of code that doesn't work is if you previously had a slightly smaller pile that worked and then added a little bit to it. So at least now you know where the broken thing is.\n\nIf you haven't got time to do ten minutes of thinking you can always do two hours of frantic debugging instead.", "id": "e4yimkv", "replies": []}]}]}], "title": "Any tips on how to solve problems and ask for help, for programmers with low tolerance to frustration?"}