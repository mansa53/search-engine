{"url": "https://www.reddit.com/r/learnprogramming/comments/9bgsqi/how_should_pointers_in_c_be_taught_to_students/", "text": "Just a little context: I\u2019m an undergrad engineering student who has volunteered to tutor my juniors who are taking the C programming language this semester. This peer tutoring programme is authorized and organized by the university.  This week, I\u2019m going to emphasize on pointers to my students, but I\u2019ll openly admit that pointers is my weakest part of this subject. And I know being weak at it is going to make me bad at teaching it.\n\nSo what do you think is the best approach to learning/teaching pointers ? Any advice/help would be very much appreciated !", "score": 1, "comments": [{"body": "What helped me is imagining a computer memory. Memory is constantly changing. If you want to keep track of a certain place in memory, you use a pointer to store the address of that memory location. I know you asked about C, but I learned about pointers with c++. This resource has some images of memory cells, it's values, and the addresses: http://www.cplusplus.com/doc/tutorial/pointers/", "id": "e52xu6f", "replies": []}, {"body": "Pointers are unsigned integers that store the address of data in memory. When you declare a variable `int x = 10`, that creates a name that is associated with an address in memory and writes the value `10` at the address. Then you can imagine that in every program there is a table of `(name, type, address)` values that keeps track of every variable you have, when you refer to a variable, the program will look up the name, and read the data at `address` (which will be a series of 1's and 0's) and decode it into a value of the `type`. The pointer is a lower level way of thinking about accessing values, it's a direct access to the values stored in memory. Instead of calling `x` to return `10`, you can store the address of `x` and directly access the value at the address. You can even change the value that is stored at x's address, thereby changing the value of x without ever reassigning x.\n\nAt an abstract level, you can imagine all values as been stored in some vault, the lockers in the vault are all numbered. Without pointers, when you want something stored you go to the front-desk, leave your things, the front-desk puts your stuff in a locker and records down your name. The next time you ask for your stuff, they look up your name and retrieve your things. You never know what number locker your things were put in, the front-desk keeps track for you. Now with pointers you can directly refer to a locker number, this immediately opens up some opportunities and risks. You are now allowed to refer to a locker that you didn't own or place things in, these lockers may contain bombs that are retrieved which explode in your face (de-referencing garbage is a common pointer related bug). Lockers can only be associated with one name, but with locker numbers you can now share your locker with other people who can access what's inside your locker without having to make a copy of the contents for themselves, this is vital to efficient operations on strings, arrays and structs. The cost of this efficiency is that you have to keep track of the locker numbers yourself, make sure nobody sharing the same locker makes unwanted changes that will affect the others and be very careful not to accidentally access a locker with unknown contents.\n\nThe concept of a pointer is well illustrated by searching \"C Pointer\" on Google images. The real difficulty in my opinion is getting your head around all the `*`, `&` and `->` syntax in C as well as maintaining a mental model of the computer memory rather than an name-value based abstraction.", "id": "e52yxu6", "replies": []}, {"body": "Yes I think you got it. I'm sure you can work the analogy to suit your examples. The point is to give them a visual paradigm that is memorable so to speak so they can easily understand how to do pointer math and with regards to allocation, use special colors for the pegs the should be freed. Don't forget to make it fun.", "id": "e533bj9", "replies": []}, {"body": "I found the concept of a pointer very simple, it's just a memory address of some data. This was drilled into me over and over again but we were never taught WHY they were useful. I found this extremely frustrating. We learnt about dereferencing, address operators, pointer arithmetic, relationship between arrays and pointers, and we were given arbitrary exercise to demonstrate these concepts but all of these things could be done without pointers, leaving me baffled. It wasn't until I taught myself about manual memory management and malloc that it made sense.\n\nThe exercises which made it really click were: creating a function to do something to an array with a pointer and length given as arguments and to create an array of pointers to structs at a length given by the user.\n\nAnd please, no analogies. At best they're unnecessary, at worst they're confusing. Concentrate on teaching how to use them.", "id": "e53c5un", "replies": []}, {"body": "I always visualised memory as Lego blocks on a grid. Not sure if this helps, but some students may be comfortable with abstract notions and others will need a visual model. A brief description of a memory page and an address table using Legos and a notepad might help.\n\nYou're probably thinking Legos are too childish and maybe a grid on the board will suffice. It possibly is, but they'll never forget Legos and with teaching, I believe that is the point.\n\nGood luck and be memorable.", "id": "e52xpwu", "replies": [{"body": "Agreed Lego blocks work nicely. It is important to mention handling the life cycle of memory too though.\n\nWhen you put something on the heap it needs to be freed manually, however this makes it tricky because a pointer may still store an address too it.", "id": "e52ynnx", "replies": []}, {"body": "That\u2019s a cool idea...did they describe a single peg as a byte and show how blocks are different sizes, corresponding to different types?", "id": "e530ejp", "replies": []}]}, {"body": "Look up how pointers are taught in **The C Programming Language** book.  That's how I learned C (many years ago) and found it to be very well written and fairly easy to follow.  The main thing to get across is that pointers are an \"address\" of something and you always need to keep that in mind when coding.  They are also very powerful if used correctly -- lots of examples would be good.", "id": "e52xutj", "replies": []}, {"body": "!remindme 24h", "id": "e52xmg2", "replies": [{"body": "I will be messaging you on [**2018-08-31 05:21:05 UTC**](http://www.wolframalpha.com/input/?i=2018-08-31 05:21:05 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/learnprogramming/comments/9bgsqi/how_should_pointers_in_c_be_taught_to_students/)\n\n[**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=Reminder&message=[https://www.reddit.com/r/learnprogramming/comments/9bgsqi/how_should_pointers_in_c_be_taught_to_students/]%0A%0ARemindMe!  24h) to send a PM to also be reminded and to reduce spam.\n\n^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=Delete Comment&message=Delete! e52xmmz)\n\n_____\n\n|[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=Reminder&message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&subject=List Of Reminders&message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/)\n|-|-|-|-|-|-|", "id": "e52xmmz", "replies": []}]}], "title": "How should pointers in C be taught to students ?"}