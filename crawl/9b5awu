{"url": "https://www.reddit.com/r/learnprogramming/comments/9b5awu/how_bad_is_my_code_pt_2/", "text": "Four months ago I posted [this](https://www.reddit.com/r/learnprogramming/comments/8f5q6w/c_am_i_going_overkill_with_oop_in_my_program/) thread here and some pretttty ugly code with it. I got ALOT of good feedback, and I've been trying to work on making my code better, and actually ended up starting that project from scratch recently, trying to incorporate some of what I was told in that thread. I am not super far into it, but is my OOP any better now? What mistakes am I still making and what can I do better?\n\n[https://github.com/Chudleyj/AlgoBot](https://github.com/Chudleyj/AlgoBot)", "score": 3, "comments": [{"body": "I know a lot of the advice you got last time was to try to incorporate more OOP into your program, but that isn't necessarily always the best advice. There are other paradigms for structuring code; functional programming being the most prominent alternative.\n\nI'll defer briefly to [John Carmack](https://web.archive.org/web/20130819160454/http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/):\n\n> My pragmatic summary:  A large fraction of the flaws in software development are due to programmers not fully understanding all the possible states their code may execute in.  In a multithreaded environment, the lack of understanding and the resulting problems are greatly amplified, almost to the point of panic if you are paying attention.  Programming in a functional style makes the state presented to your code explicit, which makes it much easier to reason about, and, in a completely pure system, makes thread race conditions impossible.\n\n> ...\n\n> Michael Feathers @mfeathers:   OO makes code understandable by encapsulating moving parts. FP makes code understandable by minimizing moving parts.\n\nAnyway, I'm going to provide some lower-level feedback on your code.\n\n**Strings and Passing by Reference**\n\nIn C++, which is designed in many ways to give you fine control over the execution of your program, it's typical that you want to avoid incurring unnecessary costs, even if they end up being slight. In other words, try to avoid obvious inefficiencies (provided that it doesn't convolute your code).\n\nTake this function, for example:\n\n    Json::Value IEX::stocks::batch(std::string symbol){\n      Json::Value jsonData;\n      std::string url(IEX_ENDPOINT);\n      url+=\"/stock/\"+symbol+\"/batch\";\n      IEX::sendGetRequest(jsonData, url);\n      return jsonData;\n    }\n\nHere, we take the `symbol` parameter *by value*. That's what the default is, meaning that we obtain a copy of it. However, there's no need to obtain a copy; we could just borrow the caller's until we're done (promising not to modify it in the meantime). This can be done by instead taking it by *const reference*:\n\n    Json::Value IEX::stocks::batch(const std::string& symbol){\n      Json::Value jsonData;\n      std::string url(IEX_ENDPOINT);\n      url+=\"/stock/\"+symbol+\"/batch\";\n      IEX::sendGetRequest(jsonData, url);\n      return jsonData;\n    }\n\nYou don't need to change anything other than the type of the parameter (you'll also have to change the declaration in the header). Pretty much all of your `string` parameters could instead be passed by `const` reference (but I'm not going to repeat this again).\n\n**\"Helper\" Functions**\n\nI see a lot of repetition (or maybe boilerplate is a better word) in your code, and it can probably be cut down a lot by having a handful of helper functions.\n\n\n* `IEX::stocks::batch`\n* `IEX::stocks::book`\n* `IEX::stocks::chart`\n* `IEX::stocks::chartDynamic`\n* `IEX::stocks::company`\n* `IEX::stocks::delayedQuote`\n* `IEX::stocks::earnings`\n* `IEX::stocks::effectiveSpread`\n* `IEX::stocks::financials`\n* `IEX::stocks::stats`\n* `IEX::stocks::largestTrades`\n* `IEX::stocks::logo`\n* `IEX::stocks::peers`\n* `IEX::stocks::previous`\n* `IEX::stocks::price`\n* `IEX::stocks::relevant`\n* `IEX::stocks::timeSeries`\n* ... (there are more but I got bored)\n\nThey all look exactly like this:\n\n    Json::Value THE_FUNCTION(std::string symbol){\n      Json::Value jsonData;\n      std::string url(IEX_ENDPOINT);\n      url += SOMETHING + symbol + SOMETHING_ELSE;\n      IEX::sendGetRequest(jsonData, url);\n      return jsonData;\n    }\n\nYou should definitely avoid repeating yourself like this so many times. Personally, I would go for something like:\n\n\n    Json::Value obtainJson(std::string path) {\n      Json::Value jsonData;\n      std::string url(IEX_ENDPOINT);\n      url += path;\n      return jsonData;\n    }\n\nThis captures the commonality of all of the above ones, so we can cut down to what we're actually doing:\n\n    Json::Value IEX::stocks::largestTrades(std::string symbol) {\n      return obtainJson(\"/stock/\" + piece + \"/largest-trades\");\n    }\n\nThis will make the rest of your code less repetitive (and therefore, less error-prone).\n\n**Type-Safety**\n\nC++ is a statically-typed language. And while it's not great at protecting you from memory faults (at least not when you're still playing around with pointers), it has a lot of facilities to prevent bad behavior of runtime code through static analysis.\n\nAll of your functions have pseudo-documentation in the form of an example JSON result. But they just return `Json::Value`. That means you have no idea what kind of data they actually return! Generally, a good API should present the most-accurate possible rendition of each type. Let's focus on `largestTrades` again:\n\n\n    [\n      {\n        \"price\": 186.39,\n        \"size\": 10000,\n        \"time\": 1527090690175,\n        \"timeLabel\": \"11:51:30\",\n        \"venue\": \"EDGX\",\n        \"venueName\": \"Cboe EDGX\"\n      },\n      ...\n    ]\n\nThis means we expect to return an array (`vector`, since size is not known statically) of structs, which have each of those fields present. (**Note: I'm not totally sure which JSON library you're using. You should specify in your README.** I think it's [this one](http://open-source-parsers.github.io/jsoncpp-docs/doxygen/index.html)).\n\nLet's look at `largestTrades`:\n\n    Json::Value IEX::stocks::largestTrades(std::string symbol) {\n      return obtainJson(\"/stock/\" + piece + \"/largest-trades\");\n    }\n\nFirst, we should get the value, and check that it's actually an array. For the moment, I'm going to suggest using the `<cassert>` library (it's a POSIX library) which makes error-checking relatively convenient, but it's not strictly suitable for error-handling in production programs, because it will awkwardly crash the program if the check fails.\n\nFirst, the return trade type:\n\n    struct LargestTrade {\n      double             price;\n      int                size;\n      unsigned long long time;\n      std::string        timeLabel;\n      std::string        venue;\n      std::string        venueName;\n    };\n\nThat should go in the header, since callers will need it. Note how I've aligned the fields. This makes it a bit easier to read.\n\nWe'll need to be able to turn a JSON blob into a `LargestTrade` struct. Let's define a helper function to do that:\n\n    LargestTrade intoLargestTrade(Json::Value blob) {\n      return LargestTrade {\n          blob.get(\"price\").asDouble(),\n          blob.get(\"size\").asInt(),\n          blob.get(\"time\").asUInt64(),\n          blob.get(\"timeLabel\").asString(),\n          blob.get(\"venue\").asString(),\n          blob.get(\"venueName\").asString()\n      }; // TODO: probably incorporate error-handling!\n    }\n\nNow our function. First, here's how its signature will change:\n\n    std::vector<LargestTrade> IEX::stocks::largesTrades(std::string symbol);\n\nNow, let's actually see how we need to change it:\n\n    Json::Value IEX::stocks::largestTrades(std::string symbol) {\n      Json::Value value = obtainJson(\"/stock/\" + piece + \"/largest-trades\");\n      assert(value.isArray()); // crash if it's not (and print message)\n\n      // The library is a bit awkward, and I'm not familiar with it.\n      // There is probably a better way to write the following.\n\n      std::vector<LargestTrade> result; // Create empty vector to return.\n      Json::Value::ArrayIndex i = 0; // It's just a library-provided synonym for unsigned int.\n      while (value.isValidIndex(i)) {\n          result.push_back(intoLargestTrade(value[i]));\n      }\n\n      return result;\n    }\n\nIn this way, it falls upon our library (rather than the client) to handle formatting errors. Now the user can trust that the data is formatted how it's supposed to be.\n\n", "id": "e50o0h8", "replies": [{"body": "Just wanted to add that C++11 onwards STL containers, strings, etc all implement move construction (and assignment), so ~~passing/~~returning a string by value does not incur copy overhead. However the advice to use reference semantics is absolutely invaluable, especially for custom classes; my humble suggestion would be to only allow yourself to use such \"pseudo\" copies when you're 100% confident of the presence of move semantics in the class/struct declaration.", "id": "e50q1uw", "replies": [{"body": "Move construction will only save you a copy if you pass a temporary; it will do nothing for those times you pass an l-value.\n\ne.g.\n\n    void example1(string s) {\n    }\n    void call1() {\n        example1(std::string(\"hello\")); // not copied; moved into place\n\n        std::string hello = \"hello\";\n        example1(hello); // performs copy; cannot move lvalue\n    }\n\nReturning by value is almost always fine though (i.e. *do* actually return, and don't use out-parameters whenever it's possible to avoid them)", "id": "e50q8dp", "replies": [{"body": "Very true, although in the latter case the compiler might optimise it into a move, as `hello` immediately goes out of scope after the call (ie, the call is the function's tail).", "id": "e50qbd8", "replies": [{"body": "The standard does not permit a copy elision just for being a tail call, so a conforming compiler can't perform that optimization.\n\nSpecifically, the compiler may not omit the copy constructor in this case. That's only permitted for returned values.", "id": "e51khlj", "replies": []}]}]}]}, {"body": "I just briefly read through this while getting ready for work, I\u2019m going to go through it in detail later today. This seems like a lot of good stuff, thanks!", "id": "e5122an", "replies": []}]}, {"body": "This is not good style for ?::\n\n    avgLoss[i] == 0 ? RSI.push_back(100) : RSI.push_back(100 - (100/(1+RS[i])));\n\nBetter:\n\n    RSI.push_back(avgLoss[i] == 0 ? 100 : 100 - (100/(1+RS[i])));\n\nTechnicalAnalysis::calcStochRSI does not do what you say it does (it outputs things; it does not calculate anything). Also the comment is not good. It merely repeats what the function name already says (calc obviously means calculate):\n\n    //Calculates stochRSI of a given stock\n    void TechnicalAnalysis::calcStochRSI(){\n      for(int i =0; i < RSI.size(); i++){\n        std::cout<<RSI[i] <<\", \";\n      }\n      std::cout << RSI.size() << std::endl;\n    }\n\nThis is weird:\n\n    auto main() -> int\n\nIt is weird because you only used that declaration style for main in your program. If you want to use -> for return types why not use it consistently?\n\nIn main() you declare TechnicalAnalysis TIobj; but you never use it. So it seems all the code you wrote for 'TechnicalAnalysis' will never get used and you may as well remove it all.\n\nNames of your classes should ideally be associated with 'objects' for better understanding. Take this as an example:\n\n    //One struct per JSON entry\n    struct JSONdata{\n\nI guess your comment actually means \"one object per JSON entry.\" OK. But if that's the case, why not call this class JSONEntry? Then when the reader reads such code, he can rightly read it as \"ent is a JSON Entry:\"\n\n    JSONEntry ent;\n\nAnother example is TechnicalAnalysis. What is \"a TechnicalAnalysis\"? Your code may be fine, but how is 'TechnicalAnalysis' a class in terms of objects? Maybe you could call it \"Stock\"? Then your class can denote an object. You can imagine having a stock and then calculating something on it. I'm not an expert on this but it seems that RSI is something that is often calculated for stocks, so the calcRSI method seems to apply to stocks. So just imagine you wrote this code (create a stock and then calculate the rsi of the stock):\n\n    Stock s;\n    // ...\n    s.calcRSI(historicalData);\n\nThe reason to do this is to make it make sense but also to avoid bloating your classes later. If you call your class Stock, and later you think about adding another method or property that actually doesn't have anything to do with stocks, you will probably rethink whether those things really belong there. But with an all-encompassing name like 'TechnicalAnalysis' you could literally put anything there, so eventually it defeats the whole point of having classes in the first place.\n", "id": "e50p8na", "replies": [{"body": "Oops! I was outputting the RSI values to screen to test some results and forgot to change it back before uploading :P\n\nThanks for the tips on naming, I will change my classes up! \n", "id": "e511zqr", "replies": []}]}, {"body": "Hey this is off topic but I've always wanted to make a trading bot myself in C++, how did you learn how to do this? Did you read up on stocks and finance? Does it actually work?", "id": "e51q7lh", "replies": [{"body": "I\u2019m just kind of planning things out on a white board and attempting to make code of them, then refactoring over and over. I\u2019m doing it for my undergrad thesis so I will be doing a lot of research on algorithms for the trading strategies but as far as the bot itself I\u2019m just kind of using my head to step through all the steps a bot would need. ", "id": "e52glym", "replies": []}]}], "title": "How bad is my code? (Pt. 2)"}