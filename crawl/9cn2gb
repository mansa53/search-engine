{"url": "https://www.reddit.com/r/learnprogramming/comments/9cn2gb/zappa_error_with_directory/", "text": "Any have experience with some trouble with Zappa and bcrypt? I keep getting this error:\n\n>FileNotFoundError: \\[WinError 206\\] The filename or extension is too long: 'C:\\\\\\\\Users\\\\\\\\Anon\\\\\\\\AppData\\\\\\\\Local\\\\\\\\Temp\\\\\\\\zappa-project2iu7sxor\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt\\\\\\\\bcrypt'\n\nI have no clue why it's doing this\n\nThis error comes from [os.py](https://os.py/) line 220: [https://pastebin.com/0dSfQQVf](https://pastebin.com/0dSfQQVf)\n\nEdit: traceback:[https://pastebin.com/LcdEJnHd](https://pastebin.com/LcdEJnHd)", "score": 2, "comments": [{"body": "I would assume it's something in your code that is generating a ridiculously long path, but you didn't show us that.\n\nCan you give a complete, minimal example that reproduces the problem? By \"complete\" I mean something that actually shows the problem (rather than something \"like\" the code that shows the problem). By \"minimal\" I mean that the code you post should be only that which is needed to show the problem and *NOTHING* else. If that print statement over there isn't necessary to see the problem, get rid of it. If you don't need to call that function to reproduce the problem, get rid of that function. Prune the code down to the barest minimum that will reproduce the issue.", "id": "e5btvys", "replies": [{"body": "**def** makedirs(name, mode=0o777, exist\\_ok=**False**):  \n *\"\"\"makedirs(name \\[, mode=0o777\\]\\[, exist\\_ok=False\\])*  \n*Super-mkdir; create a leaf directory and all intermediate ones.  Works like*  \n*mkdir, except that any intermediate path segment (not just the rightmost)*  \n*will be created if it does not exist. If the target directory already*  \n*exists, raise an OSError if exist\\_ok is False. Otherwise no exception is*  \n*raised.  This is recursive.*  \n*\"\"\"*  \n head, tail = path.split(name)  \n **if not** tail:  \nhead, tail = path.split(head)  \n **if** head **and** tail **and not** path.exists(head):  \n **try**:  \nmakedirs(head, mode, exist\\_ok)  \n **except** FileExistsError:  \n *# Defeats race condition when another thread created the path*  \n **pass**  \n cdir = curdir  \n **if** isinstance(tail, bytes):  \ncdir = bytes(curdir, **'ASCII'**)  \n **if** tail == cdir:           *# xxx/newdir/. exists if xxx/newdir exists*  \n **return**  \n**try:**  \nmkdir(name, mode)  \n **except** OSError:  \n *# Cannot rely on checking for EEXIST, since the operating system*  \n*# could give priority to other errors like EACCES or EROFS*  \n **if not** exist\\_ok **or not** path.isdir(name):  \n **raise**", "id": "e5bvaet", "replies": [{"body": "Put four additional spaces in front of each line. This probably isn't exactly right:\n\n    def makedirs(name, mode=0o777, exist_ok=False):\n        \"\"\"makedirs(name [, mode=0o777][, exist_ok=False])\n        Super-mkdir; create a leaf directory and all intermediate ones. Works like\n        mkdir, except that any intermediate path segment (not just the rightmost)\n        will be created if it does not exist. If the target directory already\n        exists, raise an OSError if exist_ok is False. Otherwise no exception is\n        raised. This is recursive.\n        \"\"\"\n        head, tail = path.split(name)\n        if not tail:\n            head, tail = path.split(head)\n            if head and tail and not path.exists(head):\n                try:\n                    makedirs(head, mode, exist_ok)\n                except FileExistsError:\n                    # Defeats race condition when another thread created the path\n                    pass\n    \n            cdir = curdir\n            if isinstance(tail, bytes):\n                cdir = bytes(curdir, 'ASCII')\n                if tail == cdir: # xxx/newdir/. exists if xxx/newdir exists\n                    return\n                try:\n                    mkdir(name, mode)\n                except OSError:\n                    # Cannot rely on checking for EEXIST, since the operating system\n                    # could give priority to other errors like EACCES or EROFS\n                    if not exist_ok or not path.isdir(name):\n                        raise\n\n\nAnyway,not surprised to see a recursive call here. What I would do is print the value of `name` at the beginning of `makedirs` and also print some interesting intermediate variables (like, `head` and `tail`). You could also use a debugger, but I've never done that for Python so can't offer any advice there.\n\nThe code is doing something wrong, but it's doing something wrong because you are *telling* it to do something wrong. The name you are passing in to `mkdir` is wrong. Why? Well, the name comes from the arguments to the function call. Why is *that* wrong? Those arguments came from somewhere. Keep asking \"Why is this wrong/why is this doing this?\" until you get the answer.", "id": "e5byzzy", "replies": []}]}]}], "title": "Zappa error with directory"}