{"url": "https://www.reddit.com/r/learnprogramming/comments/9biajm/java_is_there_a_way_to_start_a_thread_after/", "text": "The phrasing of this question might be wrong, as I haven't really had to work with multiple threads before.\n\n\u200b\n\nBasically I have a very simple application that consumes data in real time from a source using spark and kafka.\n\n\u200b\n\nI have the application in two parts, one that starts a spark streaming process and processes the data, and another that consumes the data from a source. Right now I have it set up so that they run in two seperate threads. My problem is that the spark stuff can take a few seconds before it is up and running, while the consumption stuff starts almost immediately, meaning that I lose some data at the start, because the spark process isn't up and running to process it.\n\n\u200b\n\nIs there a way I can ensure the consumption thread only starts once the spark thread has started (or has been up and running for like 10 seconds?)\n\n\u200b\n\nBasically my code looks like this\n\n\u200b\n\n    public class StreamApp {\n    \n    \t\n    \n    \tprivate static final String bootstrapServers = \"localhost:9092\";\n    \n    \tprivate static final String\\[\\] topics = {\"topic1\", \"topic2\"};\n    \tpublic static void main(String\\[\\] args) {\n    \t\t\n    \n    \t\t//Start spark streaming process\n    \n    \t\tSparkProcessing sp = new SparkProcessing();\n    \n    \t\tnew Thread(sp).start();\n    \n    \t\t\n    \n    \t\t//Start consumers\n    \n    \t\tConsumer consumer = new Consumer(bootstrapServers, topics);\n    \n    \t\tnew Thread(consumer).start();\n    \n    \t}\t\n    \n    }\n\n\u200b\n\nBut basically the conumser thread starts before the sp thread has finished starting. Whereas I want to look something like this:\n\n\u200b\n\n    public class StreamApp {\n    \n    \t\n    \n    \tprivate static final String bootstrapServers = \"localhost:9092\";\n    \n    \tprivate static final String\\[\\] topics = {\"topic1\", \"topic2\"};\n    \tpublic static void main(String\\[\\] args) {\t\t\n    \n    \t\t//Start spark streaming process\n    \n    \t\tSparkProcessing sp = new SparkProcessing();\n    \n    \t\tnew Thread(sp).start();\u200b\n    \t\t\\*\n                     * Consumer thread only starts after the first thread is up and running, or at least is     delayed starting for 10 seconds\n    \t\t*/\n    \n    \t\t\n    \t\t//Start consumers\n    \n    \t\tConsumer consumer = new Consumer(bootstrapServers, topics);\n    \n    \t\tnew Thread(consumer).start();\n    \n    \t}\t\n    \n    }\n\n\u200b\n\nIs there a way I can accomplish this?", "score": 1, "comments": [{"body": "Look into monitors and semaphores and mutex. Then study up on notify() function in java. That should tell you how to schedule threads.", "id": "e53911e", "replies": []}, {"body": "You can call Thread.sleep after the thread.start. This will block the main thread while the spark thread starts up. \n", "id": "e537o46", "replies": []}, {"body": "Put a dummy `Object` field into your `SparkProcessing` that will serve as a signalling conduit, and a `boolean ready=false` field that will let you track state.  (Or use a proper state `enum`.)\n\nAdd a method to `SparkProcessing` that does something like\n\n    synchronized(stateLock) {\n        for(;;) {\n            if(ready) return false;\n            stateLock.wait(...);\n        }\n    }\n    return true;\n\nYou\u2019ll probably want one such method to wait indefinitely (just `wait()`), and you might want another to wait with a specific timeout\u2014probably good to throw an exception or something if it times out, to distinguish from already-started vs. waited results.\n\nThe `SparkProcessing` startup routine should start itself normally, and once it\u2019s ready for other things to run, it should do something like\n\n    synchronized(stateLock) {\n        ready = true;\n        stateLock.notifyAll();\n    }\n\nWhen booting the startup thread, once you\u2019ve started the `SparkProcessing` and done anything else non-timing-critical, you can call its wait method.", "id": "e53hrwj", "replies": []}, {"body": "It sounds like you have a stereotypical example of the producer/consumer pattern. It sounds like the thing you call `Consumer` is generating data that will be used by the thing you call `SparkProcessing`. And I'm assuming that both of those classes are of your own making. If that's right, then the thing called `SparkProcessing` is acting as the consumer and the thing called `Consumer` is acting as the producer. From now on, those are the names that I will use. If my assumptions are wrong, let me know. Also, full disclosure, I have no experience with Spark, so I may misunderstand how it works.\n\nSomething you didn't show is how data is exchanged between the producer and the consumer. When you have a producer/consumer problem, it's common to use some sort of queue to exchange data between them. Java has the [`BlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html) interface, along with some common implementations like [`ArrayBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html) and [`LinkedBlockingQueue`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingDeque.html). For your case, `ArrayBlockingQueue` would probably be fine.\n\nIn use, the producer will push values into the `BlockingQueue`, and the consumer will pull values out of the `BlockingQueue`. If the queue is full when the producer tries to push a value (using [`put()`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#put-E-)), it will block. If the queue is empty when the consumer tries to pull a value (using [`take()`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#take--)), it also blocks. \n\nThis approach has several advantages. The threads can both start immediately, and the producer can actually start producing data before the consumer starts consuming data, and that data will all get buffered. It also allows you to have multiple producers and multiple consumers all interacting with the same queue. \n\nThis all assumes that the data is exchanged in-process. If that's not the case - if the data is instead posted to some blackboard (i.e. a single, shared slot) by the producer and read from the blackboard by the consumer - then synchronization becomes more complicated. One way to pause one thread until something interesting happens is to use a [`CountDownLatch`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html). The CDL allows one set of threads to wait until some event occurs N times. In your case, you'd construct the CDL with an argument of `1` (meaning \"wait for one event\"). Either your producer thread (at the start of that thread) or your main thread (before it starts the producer thread) would call [`await()`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html#await--), which will cause that thread to become paused. When the consumer is ready for data, it would call [`countDown()`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html#countDown--). This will bring the latch's internal value to 0, which will allow the producer thread to continue from the point that it paused. \n\nBut you may need more synchronization than that. If indeed the two processes exchange data via a blackboard, then the producer can't write a value to the blackboard until the consumer has read the previous value, and the consumer can't read a value until the producer has overwritten the previous value. \n\nOther people recommend using monitors and mutexes. I would agree that it's good to *know* how to use these things, but you should avoid using them if you can use the higher-level Java synchronization abstractions. For example, in Java, monitors can suffer from \"spurious wakeups\" ([doc](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--)) (which seems silly but is essentially a performance optimization). This is subtle and commonly overlooked. Low-level synchronization is *sometimes* the correct approach, but it's easy to get wrong. The higher-level synchronization abstractions take care of those kinds of details.\n\nThe `Thread.sleep` suggestion is the hackiest approach. It will work as long as you pick a long enough sleep duration, but it's hard to know how long of a duration to pick. You either pick too long of a duration and wait around doing nothing, or you pick too short of a duration and lose some data. Worse, the needed delay might vary from run to run, so for correctness' sake, the conservative estimate is to \"round up\". Depending on the particulars of your problem, you might have no other option, but it should be the \"if all else fails\" solution.\n\nIf you want a *really* good book on all of this, I highly recommend [Java Concurrency in Practice](http://jcip.net/). ", "id": "e53mci7", "replies": []}], "title": "[Java] Is there a way to start a thread after another thread starts?"}