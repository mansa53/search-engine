{"url": "https://www.reddit.com/r/learnprogramming/comments/9cszjt/how_have_learning_about_algorithms_and_data/", "text": "How have you incorporate your knowledge of algorithm design and data structure in your programming tasks?", "score": 1, "comments": [{"body": "I use data structures multiple times a day. The most common is a vector or dynamic array (ArrayList in Java, list in Python). Working with lists of objects where you don't know the size up front is super common, and the vast majority of the time it's nice to have random access to them (which is why a vector is preferable to a linked list).\n\n&#x200B;\n\nThe next most common is a Map or Set - like a HashMap/HashSet, or TreeMap/TreeSet in a language like Java, or a dict or set() in Python, etc. - pretty much every language has them, and these come in handy all the time.\n\n&#x200B;\n\nAfter that, there are many other data structures that come up from time to time, and others that are good to know about even if it's rare to ever have the need.\n\n&#x200B;\n\nIt's rare to invent a new generic data structure, as all of the obvious ones have been invented already. But it's incredibly common to need a custom data structure that's just composed out of other data structures. All of your knowledge from data structures classes helps you to do this well.\n\n&#x200B;\n\nAlgorithms are similar. I call existing algorithms all the time - like sorting, binary searching, random sampling, newton's method, etc. - actually writing an algorithm is less common, but there are a few that come up a lot - for example, BFS and DFS are ones that I often end up writing because it's easier to just write it, than to try to reuse a generic algorithm. In comparison, the vast majority of time it's easier to call an existing sorting function that's better than anything I could write.\n\n&#x200B;\n\n&#x200B;\n\n&#x200B;", "id": "e5d3cby", "replies": []}, {"body": "> How have you incorporate your knowledge of algorithm design and data structure in your programming tasks?\n\nWell, for starters it makes me understand how a database works. So you understand what adding an index really does, you can calculate how many operations will it on average take to get a specific set of data and whatnot. In the same fashion you can look at HashMaps, Sets, Linked Lists, Arrays, Tries, stuff like sorting and understand the tradeoffs that come with each instantly. This makes you avoid horrible solutions which in turn makes application itself faster and your development itself is quicker (as you don't reinvent the wheel and start with something bearable). \n\nYou also know when a given problem likely will NEVER have the best solution that can work at anything remotely fast and that you will just need to get it \"well enough\". Example: you are to deliver packages to 5 locations - A,B,C,D and E. [Here's a drawing depicting it](https://puu.sh/BpqLI/9267610925.png), numbers showing distance between locations. Find an optimal, shortest route that visits all these locations. Spoiler alert - guaranteed best solution to this is O(n!). Aka for mere 5 locations you already have 120 possibilities. For as little as 10 - 3628800. \n\nSecondly, it actually opens your eyes to solutions you wouldn't think of otherwise. Example from my work - we needed a system that could automatically assign emails/tickets to a correct employee. This included checking a language, subject etc. You could spend two weeks writing a god knows how many if clauses, arrays of words etc... or you can do it in a day if you have ever heard of Naive Bayes which is among the simplest machine learning algorithms which will do it all for you, just need to clean up the input for it. Or you might want to build a recommendations system for a bookstore - eg. if user A liked a book C then they will also like D because another user B has similar tastes and rated it highly. This is easy if you have heard of KNN algorithm... and a damn nightmare if your algorithmic knowledge is nil.\n\nAlgorithms and data structures are everywhere and sit at the very base of programming. They are basically recipes for sets of problems. Be it directly like examples above and indirectly (when you use them without even thinking, by skipping solutions you know would be trash or knowing in what field of problems your fits so you know where to start reading).", "id": "e5d4j3o", "replies": []}, {"body": "Full stack web dev: never had to truelly implement a data structure in the apps that I build. I work for an agency and the most projects involve super-nested objects of data. Having said that data modelling is a massive component: how to build your data sets in efficient ways using normalisation/denormalisation. Data modelling become more important the further you get from the UI (when developing backend APIs or parsing data).\n\nNot had a reason to implement stack, queues, or trees yet.\n\nI also do mobile development and that\u2019s where you\u2019ll need to get your head around data structure. iOS more than Android, Android is better for beginners even though better means significantly more complex than web development.\n\nWhen it comes to things like arrays and objects I don\u2019t class them as proper data structure, they\u2019re more like primitive/basic data structures.", "id": "e5d4kok", "replies": []}], "title": "How Have Learning About Algorithms And Data Structures Make You A Better Computer Programmer?"}