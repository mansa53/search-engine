{"url": "https://www.reddit.com/r/learnprogramming/comments/9bxxhj/how_should_i_think_aboutapproach_command_line/", "text": "I know there are a plethora of command line arg parsing libraries out there for various languages, but would like to build my own (purposely re-invent the wheel) to learn and truly understand the best way to solve this problem. The issue is no matter how I approach the problem or try to think about it in a different way I keep hitting scenarios where my solutions would fail.\n\nLet's use the following cli interface as an example:\n\n    app --log <file> --things <thing>... <action>...\n\nSo we have an app, it has an 2 optional options --log and --things. --log takes exactly 1 arg which is a path, and --things takes a variable number of args. The program itself takes a variable number of args (actions).\n\nWhen trying to create a parser for this make believe app, how would you approach it? How would you know when --things args end and the programs args begin, since they are both variable lengths? Am I thinking about this to linearly? One of my earliest approaches to arg parsing was simply to look at '-' characters, using them to separated out options and adding any additional args given after them until the next '-' appeared. This solution is far from robust but is the simplest way I've found that works (sort of, depending on the programs requirements). I started writing a library to make this more robust, using proper OOP and encapsulation, but the complexity keeps growing and there seems to be an infinite number of edge cases to worry about. I haven't tried a recursion approach yet but I can't see how that would work either. \n\nTLDR - What does a robust arg parsing solution look like at a high level? How should I think about/visualize this problem? ", "score": 1, "comments": [{"body": "To all following commenters: please, do not bring up the old circlejerk \njokes/memes about recursion (\"Understanding recursion...\", \"This is \nrecursion...\", etc.). We've all heard them n+2 too many times.\n\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/learnprogramming) if you have any questions or concerns.*", "id": "e56jxx0", "replies": []}, {"body": "If you are providing an example, proviide a _real_ example - a real program with real options. Yours is far to vague and of course things like `<` and `>` wil be consumed by the shell as redirection instructions.\n\nWriting a command line parser is not at all easy, and at the end of the day you need to make some compromises about how it will work with your applications. And after all, it's the applications that are the important things, not the command line parser.", "id": "e56kbzv", "replies": []}, {"body": "what language are you using", "id": "e56k78y", "replies": [{"body": "Python", "id": "e56m65e", "replies": [{"body": "Have you looked at the argparse library which is part of the Python distribution. Even if you want to write a better command line parser (which is certainly possible) you should know what is already available.", "id": "e56rmlo", "replies": []}, {"body": "In python, `sys.argv` is a list of arguments, where each argument was split by the OS shell on each space character, unless that space was contained in a quoted string. If your program was invoked by an OS execute command, it's possible that it received a more complex command line argument as well.\n\nFrom there, it's up to you to `for` loop over the list, and pick out each command like `--log` and each command argument `<file>` from that list and pair them off.\n", "id": "e56rcvl", "replies": []}]}]}, {"body": "`--things=thing1,thing2` is common. Or including the same option multiple times  with a different argument each time. Or do what `find -exec` does and have a special token to mark the end.", "id": "e56kd60", "replies": []}, {"body": "If you have a string \" --log <file> --things <thing>... <action>... \" You could create a list of words (based on the spaces), then look for whatever argument's you might expect.\n\n    List<String> usefulArguments = new ArrayList<String>(\"--log\");\n    \n    List<String> actualARguments = input.explode(\" \");\n    \n    for(String s : usefulArguments)\n    {\n        if(actualARguments.contains(s) \n        {\n            \n        }\n    }\n\n&#x200B;", "id": "e56kv0v", "replies": []}], "title": "How should I think about/approach command line argument parsing?"}