{"url": "https://www.reddit.com/r/learnprogramming/comments/9bmt1g/need_help_understanding_data_types/", "text": "    unsigned u = 10;\n    int i = -42;\n    std::cout << i + i << std::endl; // prints -84\n    std::cout << u + i << std::endl; // if 32-bit ints, prints 4294967264\n\nI understand the first cout statement but I can't seem to figure out why the second one prints out that grisly number. The explanation given in my book isn't making any sense to me.", "score": 0, "comments": [{"body": "> I understand the first cout statement \n\nWell, I don't understand it. For me:\n\n    #include <iostream>\n    int main() {\n        unsigned u = 10;\n        int i = 42;\n        std::cout << i + i << std::endl; // prints -84\n        std::cout << u + 1 << std::endl; // if 32-bit ints, prints 4294967264\n    }\n\nprints out the expected:\n\n    84\n    11", "id": "e546bb0", "replies": [{"body": "Crap really sorry about that. i is supposed to be -42.", "id": "e546hd2", "replies": [{"body": "The output is then:\n\n    -84\n    11\n\nPlease try compiling and running the code before posting these sorts of questions.", "id": "e546twy", "replies": [{"body": "My brain's gone vacationing, the 1 is supposed to be i.", "id": "e546y3t", "replies": []}]}]}]}, {"body": "What's the explanation from the book?", "id": "e5469ux", "replies": [{"body": "This is the explanation given earlier\n\n>If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold. For example, an 8-bit unsigned char can hold values from 0 to 255, inclusive. If we assign a value outside this range, the compiler assigns the remainder of that value modulo 256. Therefore, assigning -1 to an 8-bit unsigned char gives that object the value 255.\n\nAnd then later below my question, it says:\n\n>In the second expression, the int value -42 is converted to unsigned int and the addition is done. Converting a negative number to unsigned behaves exactly as if we had attempted assign that negative value to an unsigned object. The value \"wraps around\" as described above.\n\n&#x200B;", "id": "e546uiv", "replies": [{"body": "Basically unsigned types can only store positive numbers.\n\nif you try to put a negative number in an unsigned type it will wrap around and become a very large value. \n\n\nIt basically works like old mechanical [odometers](https://en.wikipedia.org/wiki/Odometer) in cars: if you go past 999999 you end up at 0 again and if you go bellow 0 you'll roll over to 999999 (but unsigned 32 bit numbers can store values up to 4294967295).", "id": "e547s3h", "replies": [{"body": "In that case shouldn't it print 4,294,967,263 instead of 4,294,967,264?", "id": "e5481vz", "replies": [{"body": "Nope, 4 294 967 295 corresponds to unsigned(-1) so unsigned(-32) is 4 294 967 295 - 31 = 4 294 967 264", "id": "e5491ia", "replies": [{"body": "Ohhh. Thank you so much!!!!", "id": "e549vad", "replies": []}]}]}]}]}]}, {"body": "2nd one is maybe because of implicit type conversion.", "id": "e546mtu", "replies": []}, {"body": "Unsigned numbers are always treated as positive.  By subtracting 42, you're making the bit pattern for a negative number (with the high bit set).  When it's interpreted as a positive number, that comes out to being a very large value.", "id": "e546o5m", "replies": []}, {"body": "`u + i` is `-32`. In 32-bit hexadecimal, it's same as `0xFFFFFFE0`. As unsigned integer, it's `4294967264`.", "id": "e54a48c", "replies": []}], "title": "Need help understanding data types"}