{"url": "https://www.reddit.com/r/learnprogramming/comments/9ab9xd/unityc_coded_a_script_that_chooses_from_a_list_of/", "text": "I wanted to give myself the option of choosing randomly from a weighted list, without having to hard-code in a bunch of if statements and comparison operators every time, as I'm working on an RPG and that would quickly become tedious. So instead I tried to make a generic function that I could call from anywhere that could return a choice from a list of options, as long as I passed in a dictionary containing the list of options as the keys, and the probability of each option as the values. This is what I came up with.\n\n\nhttps://gist.github.com/lDaymarel/4d1fd1f17dc051f66ad047e800dbab4a\n\n\nAfter testing I found that it works pretty solidly, but as I'm completely self-taught and relatively new to programming I'm sure there are a lot of mistakes or things that could be done better, or maybe there's already a better implementation for this kind of thing that everyone uses and I just couldn't find. Could I have some opinions?\n\n\nAlso feel free to use this code for yourself if you want I don't mind.", "score": 1, "comments": [{"body": "What is the time complexity of your algorithm?\nWhat is the space complexity of your algorithm?\n\nSome of your code could be run statically. Like building your lists. You could make the lists for 100 total percent. Then just bound your entry into the list if the total percent is less than 100. ", "id": "e4u8gl4", "replies": [{"body": "Sorry like I said I'm relatively new to coding so I'm not sure what most of that means. Through some googling, if I'm understanding correctly, time complexity is how long it takes to run? If that's the case I've done tests of up to 10k objects that are returned almost instantly. \n\nIn terms of space complexity, assuming you mean how much storage space the algorithm needs to run, I'm not quite sure how to go about finding that out.\n\n\nI'm not entirely sure what you mean with the second part. Again sorry I'm still at barely an intermediate level.", "id": "e4uan4k", "replies": []}]}, {"body": "My opinion is that if it works, move on to the next thing. Don't optimize without the need, and you don't need to optimize unless your benchmarks say otherwise. If you haven't at the very least haven't done any profiling, then don't worry about optimizing.", "id": "e4ua9x4", "replies": []}, {"body": "> Is there a more efficient way I could've done this?\n\nYes. \n\nThe very first thing you do is iterate through the options making sure they add up.\n\nBy the time you have done this you could be finished! That means everything else in your method is not needed at all. If you cut that out it will be more efficient.\n\nSuppose I have these options with their weights:\n\n A 25\n \n B 30\n \n C 5\n \nThe total is 60.\n\nAny number between 1 and 25 will give you A.\n\nAny number between 26 and 55 will give you B.\n\nAny number between 56 and 60 will give you C.\n\n\nNow, look at your `checkSum` as you iterate through the list. It goes 25, 55, 60. These are the upper bounds on the ranges.\n\nSo, you can start by picking a random integer between 1 and 60. Let's say it is `randomNumber = 42`\n\n * Look at A, the checkSum is 25. Is 42 <= 25? No. That's not it.\n\n * Look at B, the checkSum is 55. Is 42 <= 55? Yes. That's the one!\n\n * Look at C, the checkSum is 60. (Already found the answer, so don't check again.)\n\nChecksum is 60, all is well, return 'B' as the chosen option.\n\nYou should be able to code this up so that by the time you have done validating the weights you have got your result.\n\nGood Luck!", "id": "e4utcm0", "replies": []}], "title": "[Unity/C#] Coded a script that chooses from a list of items with weighted probability. Is there a more efficient way I could've done this?"}