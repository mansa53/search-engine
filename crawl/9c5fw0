{"url": "https://www.reddit.com/r/learnprogramming/comments/9c5fw0/question_about_reference_and_pointers_in_c/", "text": "Hello All,\n\nNew programmer here, and I had a question in regards to passing strings, vectors, and arrays.\n\nExample: \n\n\n\n\nvoid StringPointer(char someString[]) {\n   //some programming logic here\n}\n\nvoid VectorReference(vector<int>& someVector) {\n   //some programming logic here\n}\n\n\n\n\n\nWhy is a string array accessed as a pointer automatically, but when I utilize vector I have to specify if it's a reference or a pointer.\n\nTried to find my question via google, but I think I am asking the wrong question maybe? Any feedback would be helpful. \n\nThanks\n\n\nEdit:\n\nAmazing feedback on everyone's account. Thanks across the board. Cheers!", "score": 0, "comments": [{"body": "Vectors act a lot like arrays, but they aren\u2019t one. They\u2019re actually not a built in part of the language, and they\u2019re not any different from any other class or struct.", "id": "e589h4j", "replies": []}, {"body": "    T x[10];\n\nDeclares an array of sufficient size to hold 10 objects of type `T`, but what isn't obvious is that ~~x is of type T*~~ (Edit: I stand corrected) when present as a function parameter `(T x[])`, `x` decays to type `T*`, and points to the first element in the array. In other words, `*x == x[0]`. Or, `*(x + i) == x[i]`.\n\nSo `char x[]` in a function signature is equivalent to `char* x`. An array of one element - at least in C/C++ - takes exactly as much memory as an object of that type, therefore `T*` can effectively represent both a pointer to one object or an array of them. Since a called function will be unable to differentiate between the two, you should always also pass in the length of the array, which when = 1 is assumed to be a pointer to a single object, by the function. That's one of the minor reasons to use `vector` instead.", "id": "e584t49", "replies": [{"body": "> Declares an array of sufficient size to hold 10 objects of type T, but what isn't obvious is that x is of type T*, and points to the first element in the array. In other words, *x == x[0]. Or, *(x + i) == x[i].\n\nNit pick... this isn't entirely true.\n\n    T x[10];\n\ndoes declare x to be an array of 10 T's. If you do something like this:\n\n    int main()\n    {\n      int x[10];\n      std::cout << sizeof x << std::endl;\n      return 0;\n    }\n\nit will return a value of sizeof(int) * 10. (Typically 40 when int's are 32-bit.)\n\nBut most uses of x in an expression will automatically convert it to a pointer to the first element. So, yes, `*x == x[0]` and `*(x + i) == x[i]`... in all of those expressions, usage of x 'decays' to a pointer-to-first-element-of-x.\n\n> Since a called function will be unable to differentiate between the two, you should always also pass in the length of the array, which when = 1 is assumed to be a pointer to a single object, by the function. That's one of the minor reasons to use vector instead.\n\nTotally agree. Either, the function should expect just a pointer to an object (and only access the first one), or should take a pointer and a length indicating that it accepts a (pointer to an) array.\n\nAs well as std::vector, std::array can also be used for compile-time fixed-sized arrays in C++11 onward.", "id": "e589vr8", "replies": []}, {"body": "> what isn't obvious is that x is of type T*\n\nIt's not obvious because it is not true. Its type is T[10]. Arrays will decay to pointers in many circumstances, but they are _not_ pointers.", "id": "e589qh9", "replies": [{"body": "That's a pretty subtle issue, but you are absolutely right.", "id": "e58renv", "replies": []}]}]}], "title": "Question about Reference and Pointers in C++"}