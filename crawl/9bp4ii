{"url": "https://www.reddit.com/r/learnprogramming/comments/9bp4ii/having_a_pass_by_reference_return_typec/", "text": "Hi, so say you have a function that overloads  operator= which allows you to assign one Linked List to another Linked List using the assignment operator , from what I know the function should take the form:\n\n&#x200B;\n\nIntList & IntList::operator=(const IntList &rhs){}\n\n&#x200B;\n\nI have two questions:\n\n1.) Why should it be returned by reference. \n\n2.) why is the parameter by reference. \n\n&#x200B;\n\nThanks.\n\n&#x200B;", "score": 1, "comments": [{"body": "Because the expression `a = b`, in addition to performing the assignment, evaluates to a value. For built-in types or if you've defined operator= correctly this value should be `a`. This allows you to do things like `a = b = c`.\n\nBoth the parameter and return value are references in order to avoid unnecessary constants, which could be quite expensive for large objects. Note that returning a value by reference is safe in this case because you should be returning `*this`, which is guaranteed to still be a valid reference immediately after the assignment call.", "id": "e54ok1t", "replies": [{"body": "so what you're saying is that we do this purely for efficiency reasons? I was told that if you don't return by reference, the implicit parameter passed into the function will not be updated(which does not make sense to me).", "id": "e54owxw", "replies": [{"body": "What implicit parameter? `this`? `this` will be updated correctly either way. If you have a simple assignment like `a = b;` then the return value will not be used at all. It's only needed for things like `a = b = c` or `while (a = next())`.", "id": "e54pzhe", "replies": [{"body": "Alright then I don't know why my instructor said we must return it by reference or it wouldn't work. Maybe I just misunderstood him.Thank you for your help. ", "id": "e54qtj7", "replies": [{"body": "Well the return type must be by reference because that's how the operator is defined, and as I explained above it's defined that way so it doesn't require a copy to be made. And you should always return `*this` because anything else would violate the expected contract of an assignment operator.\n\nIt's not correct to say that the object won't be updated, but it is correct to say that you should always return `*this` in an assignment operator.", "id": "e54qz36", "replies": [{"body": "yea but my question was why we define the return type as by reference when returning it by value would yield pretty much the same result minus the efficiency cost. Couldn't we do:\n\n    IntList IntList::operator=(const IntList &rhs){...\n\ninstead of:\n\n    IntList & IntList::operator=(const IntList &rhs){...\n\nwhile returning \\*this in the first form?", "id": "e54r6wx", "replies": [{"body": "Because that would create a copy of the object, which can potentially be a very slow operation. Especially when the return value is usually not used, you don't want to create an unnecessary copy. Note that the compiler cannot optimize out the copy even when it's unused, because the act of copying may have side effects.\n\nReturning a reference does not require a copy. It's a *very* cheap operation and it can't have side effects, so the compiler can even optimize it away.\n\nAdditionally the user of your class will expect it to return a reference, and may therefore use the return value expecting it to be the same object that was assigned to. If you return a copy instead then they will instead be using a different object, the copy, and this will likely not work correctly for them. The contract for an assignment operator is to return a *reference* to the assigned object, and returning a copy instead will almost certainly cause bugs in the future. Contracts are not enforced by the compiler, but you should always follow them anyways.\n\n(Note: I actually thought the first form wouldn't even compile, but I tested it and apparently it does. You still shouldn't use it.)", "id": "e54rn0t", "replies": [{"body": "That makes a lot of sense. Thank you.", "id": "e54tuf7", "replies": []}]}, {"body": "Imagine an `IntList` with a million nodes; copying that when returning by value will be pointlessly slow.", "id": "e54seyj", "replies": [{"body": "fair point, thanks for the input. ", "id": "e54tuws", "replies": []}]}]}]}]}]}]}]}, {"body": "1) Ever seen things like this?\n\n    std::cout << a << \", \" << b << \", \" << c << '\\n';\n\nThis is because `operator<<` returns `std::ostream&`.\n\nFor the same reason, if you return a reference instead of `void` in `operator=`, you can do this:\n\n    a = b = c = d;\n\n___\n\n2) To avoid deep copying the entire list. It's accessed by const reference to only read it's nodes.", "id": "e55qd9f", "replies": []}], "title": "Having a pass by reference return type?[C++]"}