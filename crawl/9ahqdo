{"url": "https://www.reddit.com/r/learnprogramming/comments/9ahqdo/sorting_algorithm_takes_longer_than_it_should_c/", "text": "Hey all\n\nso, im using C# in my data sorting class (while  professor uses C), but the work takes a lot longer than it should, eg: the same algorithm in C, working on a 1m data file, takes \\~1min, but in c# it takes 4\\~5hours.\n\nI thought it might be bc of GUI, but i build it on console and it takes the same amount of time.\n\n\u200b\n\nWhat i need to learn/do? or should i change to C?\n\n\u200b\n\np.s.: i didnt post the code bc i found it irrelevant, isnt wrong, i think im just missing the right way to use it.\n\n\u200b\n\n\u200b\n\nedit:\n\ncode of one of the algorithms, with a 500k data input, this one takes 1s for ordered data, 9:30min for inverted, and 5min for randomic, i tried to use a static value (eg 500k) instead of input.Count but nothing has changed.\n\n[https://gist.github.com/lfklucas/785f87ff22852795775d6da5799481c0](https://gist.github.com/lfklucas/785f87ff22852795775d6da5799481c0)\n\n&#x200B;\n\nedit2:\n\ninserted the code into a gist and added the methods im using to insert the input data from .txt into a list<int>", "score": 3, "comments": [{"body": "What kind of list are you passing through?\n\nArrayList or LinkedList.\n\nIf you are passing a Linkedlist, then this explains the difference in runtime. A a linkedlist makes your Code run in O(n^(3)) runtime instead of O(n^(2)) worst case, essentially making your code 500k times slower, give or take a few K.\n\n\n\nWith size N=10000\nPython which is much slower than C#; Using an array;\n>dimitris@localhost ~/p/jregexp> time python3 ./shellsort.py  \npython3 ./shellsort.py  2.87s user 0.14s system 105% cpu 2.841 total\n\nJava, using ArrayList and LinkedList:\n\n> Arraylist: 41ms\n> Linkedlist: 115602ms = 116s\n\n115602/41 = 2819.561, linkedlist is 2819.561 times slower, or around N/3 times slower. This is surprising, I expected more.\n\nCode is here:  \nhttps://gist.github.com/namedlambda/cb4223e8ae27b1543e989ac05b0c7408  \n  \n\nLets analyze the code; I will use the Java implementation since it's easier to show why this happens.\n\n    public static String shellsort(List<Integer>items ){\n        long start = System.currentTimeMillis();\n        int i, j, inc, temp;\n        inc = 3;\n        while (inc > 0) {\n            for (i=0; i<items.size(); i++){\n                j = i;\n                temp = items.get(i);\n                while ((j>=inc)&&(items.get(j-inc)>temp)){\n                    items.set(j, items.get(j-inc));\n                    j = j - inc;\n                }\n                items.set(j,temp);\n            }\n            if (inc / 2 != 0) inc = inc / 2;\n            else if (inc == 1) inc = 0;\n            else inc = 1;\n        }\n        //Check if sorted.\n        assert items.stream().sorted().collect(Collectors.toList()).equals(items);\n        return \"\"+(System.currentTimeMillis()-start)+\"ms\";\n    }\n\n\n\nBecause you are sending in a LinkedList, you are running in O(n^(3)) runtime.\n\n\n\n\n     // The forloop here, runs in Omega N time,\n     //in other words, it will run exactly N times.\n     for (i=0; i<items.size(); i++){\n                j = i;\n                // If you are using an array, this happens in constant time. \n                //If you are using a linkedlist, you need to iterate,\n                //  exactly i times. Thus, this takes O(n) time\n                temp = items.get(i);\n                // This runs on Omega(n) for both implementations,\n                //for linked list it runs in O(n^(2)) because of items.get\n                while ((j>=inc)&&(items.get(j-inc)>temp)){ \n                    // This needs O(1) time for arrays and O(2*n) for linkedlist as you\n                    //walk j times, to set and j-inc times to retrieve.\n                    items.set(j, items.get(j-inc)); \n                    j = j - inc;\n                }\n                // This, again needs constant time for arrays and O(n)\n                //for linkedlist as it needs to walk j times to that node.\n                items.set(j,temp); \n            }\n\nSo the outerloop runs n times; the while loop runs n times; the internal of the while loop runs for n times; Thus, asymptotically, using a linkedlist, you run in O(n^(3)) time.  If you have any questions, ask, I will probably answer in a few hours when I wake up.", "id": "e4voou1", "replies": [{"body": "> Because you are sending in a LinkedList\n\nIt's not a linked list. List<> in C\\# is a generic array-list.\n\nI think the problem is more that the increment value is stupidly low. Alas, even if it was set to a higher value, the code that reduces it is still nutty. If the inc is divisible by 2 then on the next round it will be set to 1. That doesn't make sense.", "id": "e4wh53z", "replies": [{"body": "Yeah figured it out.\n\nI am pretty sure OP screwed something up with his shellsort. for 0.5M elements, he is 3 sorting then 1 sorting, His sort becomes a slightly better bubble sort; \n\nWith 5M objects and proper gaps;\n\npypy:\n> dimitris@localhost ~/Downloads> time pypy ./shellsort.py  \npypy ./shellsort.py  57.58s user 0.29s system 98% cpu 58.872 total    \n\njava:  \n>Arraylist: 169449ms\n\nIt takes 1minute for pypy to sort 5M objects and 3 minutes for java\n\nSo yeah you are right, If op's sort has incr 3 then 1; his code is essentially a bubble sort.\n\ncode here:  \nhttps://gist.github.com/namedlambda/cb4223e8ae27b1543e989ac05b0c7408", "id": "e4wmb8p", "replies": []}]}]}, {"body": "> i didnt post the code bc i found it irrelevant, isnt wrong, i think im just missing the right way to use it.\n\nPerhaps, but if we can't see it, there's no way to tell.", "id": "e4vibgp", "replies": [{"body": "see the edit, hope is that the right way to post code here. (i used the inline code option on the new reddit).", "id": "e4vjzjn", "replies": [{"body": "Just paste the code as you'd have it in your IDE, but add an extra 4 spaces in front of every line (whether it has spaces already or not).", "id": "e4vkj1f", "replies": []}]}]}, {"body": "[deleted]", "id": "e4vkapc", "replies": [{"body": "Nah. Integer arithmetic, remember? `inc` starts out as 3, and `3/2` is 1. So the first time through sets it to 1. But `1/2` is  0, so the second time, first case doesn't succeed, but the second one does, setting `inc` to 0, which should cause the while loop to end.", "id": "e4vpi82", "replies": []}]}, {"body": "Did you implement the exact same shell sort algorithm in C and it runs much faster? Or did you use the one from that page in C# and the one you Prof gave you in C?\n\nTry using an array instead of a list in C# to see if that reduces the running time. \n\nAlso, you should not directly copy that code from that website. Try and understand what shell sort is doing. I would argue that a gap of 3 for an array of 500k to 1kk elements won\u2019t improve that much on the running time of insertion or bubble sort.", "id": "e4vlmvm", "replies": [{"body": "I did converted my professor c code to c# (idk why but im terrified of c), it takes little bit longer, that's why i kept the w3school version. \n\n&#x200B;\n\nFor me the time was ok, until i get to the class, my  colleagues were getting the same values with different implementations. BubbleSort took me \\~4 hours while for them \\~10minutes.", "id": "e4vmlfj", "replies": [{"body": "If the algorithm is the same, I believe the language is what is causing the difference or the data structure you are using.\n\nI would suggest using arrays instead of lists and see if that improves performance.", "id": "e4vnbuu", "replies": [{"body": "`I believe the GUI or the language is the problem`\n\nthat's what my professor said! then i thought I might need advanced skills to work w it, maybe to work w threads or  set the work to be done on background, but I know nothing about it and that's why I posted it here.\n\n\u200b\n\nIll try to use arrays instead, thanks!", "id": "e4vnuha", "replies": []}]}]}]}, {"body": "Just to make sure, are you doing a release build and executing the output exe from straight console rather than through visual studio?\n\nSomething else if you want to try, you could drop into unsafe mode and execute lower level languages for different parts.", "id": "e4vm8ev", "replies": [{"body": "rn im using visual studio, but i tried the exe too. \n\nwhat do u mean by execute lower level languages for different parts?", "id": "e4vmwfk", "replies": [{"body": "So, you can execute C or assembly inside c# if you drop into an unsafe block.\n\nI've never had the need to do that, but if you identify the slow part you may be able to micro optimize it inside one.\n\nI don't have any tutorials for it, but it may be fun for you to play with.\n\nMore importantly, have you done some performance diagnostics to see exactly which part of the C# the algorithm is churning on? There should be an option in visual studio to do some CPU sampling on the code.\n\nI'm not in front of my PC so I can't tell you the exact options. ", "id": "e4vnajj", "replies": [{"body": "I didnt know unsafe block was a thing, and I'll definitely look into it! even more so that it's something I can use in the future.\n\n&#x200B;\n\nThe only thing i did was to set a bunch of breakpoints and check if its working how it's supposed to do.\n\nIll search on how to use the VS diagnostics tools, thanks for ur suggestions :)\n\n&#x200B;", "id": "e4vpe34", "replies": []}]}]}]}, {"body": "You should post the C version too so we can compare.", "id": "e4vpy5m", "replies": []}, {"body": "Are you sure you are implementing the same algorithm? What are you sorting? Integers? Are these native integers or objects? I don't think the GUI will make much of a difference. How much memory does the program use while running?", "id": "e4vjqhc", "replies": [{"body": "yes, and i did tried to use codes that i got from web and from the book \"Algorithms, Notes for Professionals\". For now I have implemented the Bubble Sort, Insertion Sort, Selection Sort and Shell Sort, they all took a lot longer than it should. (bubble takes 5 hours for 1m data).\n\nThe program use \\~30% of CPU and \\~1% the memory.\n\n&#x200B;\n\nIm using a .txt file with integers, and this is the method i use to read it:\n\n `public List<int> ReadTxT(string path)`\n\n`{`\n\n`List<int> list = new List<int>();`\n\n`int tam = int.Parse(TBox_Tamanho.Text);`\n\n`string[] stringArray = File.ReadAllLines(path);`\n\n&#x200B;\n\n`foreach (string data in stringArray)`\n\n`{`\n\n`list.Add(Convert.ToInt32(data));`\n\n&#x200B;\n\n`}`\n\n&#x200B;\n\n`return list;`\n\n`}`\n\n`private string FileName(string tipo)`\n\n`{`\n\n`string fileName = string.Concat(string.Concat(tipo, TBox_Size.Text.ToString(), \".txt\"));`\n\n`string path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, fileName);`\n\n`return path;`\n\n`}`\n\n&#x200B;\n\n&#x200B;", "id": "e4vlf7o", "replies": []}]}, {"body": "I am new but I was taught in my CS class that you use C when speed and/or resource management is an issue.   So shouldn't you **expect** c# to run it slower?", "id": "e4vocsz", "replies": [{"body": "No, it shouldn't run that much slower. C isn't the absolute when it comes to speed and this kind of difference is not explained by language. If C# was that slower, then it wouldn't be used by anybody for any reason.", "id": "e4vozx1", "replies": []}]}], "title": "Sorting algorithm takes longer than it should C#"}