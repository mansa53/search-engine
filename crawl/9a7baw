{"url": "https://www.reddit.com/r/learnprogramming/comments/9a7baw/i_cant_understand_why_a_corner_case_for_tarjans/", "text": "So, I am trying to solve a SCC problem, and come across this algorithm. I am basing myself on this [wiki link](https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm) and [this video](https://www.youtube.com/watch?v=TyWtx7q2D7Y&t=4s) (he starts to talk about the part I am in doubt at 15:13)\n\nSo, I still haven't implemented on code, because I'm still trying to understand how some stuff work, and how I will need to change some stuff from both sources, since they are in pseudo-code. But I ran through paper the case 0R1, 1R2, 1R3, 3R0, and came to find that node 2 would be wrongly assigned as part of the component because of this line:\n\n    if(ids[at] == low[at]):\n        //...\n        low[node] = ids[at]\n\nSo, before I thought this line was just redundancy, because I couldn't find a case where it would be useful, but now, it's even starting to make mistakes on the code!\n\nI know this is a highly specific question, and it's poorly presented, but I just thought I would try my luck, thanks to anyone that spends time trying to understand this thing!\n", "score": 12, "comments": [{"body": "You are either making a mistake when you are keeping track of your recursive calls and values, or misunderstanding the algorithm/code. I think you might be confused about the \"repeat\" loop. It indicates a do while loop and does not just mean repeat until the stack is empty. Ie this:\n\n          repeat\n            w := S.pop()\n            w.onStack := false\n            add w to current strongly connected component\n          while (w != v)\n\nis equivalent to this:\n\n          w := S.pop()\n          w.onStack := false\n          add w to current strongly connected component\n          while (w != v)\n            w := S.pop()\n            w.onStack := false\n            add w to current strongly connected component\n\nIn your paper run through of the code, you should find when you come to vertex 2 that `w` *is* equal to `v` (because vertex 2 has no successors). So vertex 2 is the *only* vertex that will be added to the strongly connected component created by this code (because the loop doesn't repeat). Afterwards the algorithm returns to a previous level of recursion, and remaining vertices will be added to some other component(s) (since none of them can have a lowlink or index that matches vertex 2's index).", "id": "e4tgkdc", "replies": []}, {"body": ">     if(ids[at] == low[at]):\n        //...\n        low[node] = ids[at]\n\nThe bit that you've elided is the important part. Inside the if, there's a loop that pops successive items from the stack, assigning each to `node`. The full code is:\n\n    if(ids[at] == low[at]):\n        for(node = stack.pop();; node = stack.pop()):\n            onStack[node] = false\n            low[node] = ids[at]\n            if (node == at): break\n\nI don't like how that's written, so here's a translation:\n\n    if(ids[at] == low[at]):\n        while True:\n            node = stack.pop()\n            onStack[node] = false\n            low[node] = ids[at]\n            if (node == at): break\n \nNote that the values in `low` can change over time. So while it's true that, initially, `ids[at] = low[at] = id++`, when a cycle is detected, `low[at]` will be changed to point at a different value.\n\nIn particular, `low[x]` tracks the lowest node id reachable from the node identified by `x`. So by the time we reach the code your linked, `low[at] <= ids[at]`. If `low[at] < ids[at]`, then the node identified by `at` was able to reach a node that came before `at` - that is, there's a cycle involving `at`, but `at` doesn't have the smallest ID. In this case, it's left on the stack.\n\nEventually, we will return from our recursive calls to a point where `ids[at] == low[at]`. In this case, the node identified by `at` is the root of a SCC (even if that SCC only contains that one node). In this case, we scarf up all the nodes on the stack - those nodes *are* the nodes in the SCC.\n\nIf you have a specific example graph where you don't think this algorithm works, provide it and we can see if we can figure out why.", "id": "e4v4t81", "replies": []}], "title": "I can't understand why a corner case for Tarjan's strongly connected components algorithm does work."}