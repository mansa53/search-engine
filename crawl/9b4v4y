{"url": "https://www.reddit.com/r/learnprogramming/comments/9b4v4y/c_how_is_casting_int_to_char_related_to_bytes_in/", "text": "I found this on a website quiz. I get how ptr1 and ptr2 are 5 addresses apart so ptr2-ptr1 is 5. But I don't understand why the output for (char * ) ptr2 - (char * ) ptr1 is 20.\n\n\nint* ptr2 originally points to the address of array index 5, which contains the int value 60 or hex 0x3C. On casting ptr2 to a char*, the address it points to remains the same, even though the value 0x3C should now be interpreted as char '<' . So shouldn't subracting ptr2's address with ptr1's address after the cast also give 5? I'm missing something fundamental here.\n\n\n    #include<stdio.h>\n    int main(){\n        int arr[] = {10, 20, 30, 40, 50, 60};\n        int *ptr1 = arr;\n        int *ptr2 = arr + 5;\n        printf(\"Number of elements between two pointer are: %d.\", \n                                    (ptr2 - ptr1));\n        printf(\"Number of bytes between two pointers are: %d\",  \n                                  (char*) ptr2 - (char*) ptr1);\n        return 0;\n    }", "score": 10, "comments": [{"body": "The `int`s are 4 bytes wide.  5 * 4 = 20.  Casting to `char *` means that pointer arithmetic will be based on the size of a `char` instead of size of an `int`.\n\nFor clarity, also print out the `sizeof(*ptr2)` and `sizeof(*(char *)ptr2)`.", "id": "e50fc5n", "replies": []}, {"body": "integers take up more space than chars. There are 5 int's worth of space when those addresses are treated as ints, but 20 char's worth of space when treated as chars.", "id": "e50f7z3", "replies": []}, {"body": "Thanks for the explanations. You helped me find the actual problem: I thought incrementing a pointer would increase the address by 1 no matter what pointer type it was. But for int\\* it actually increases it by 4. Now I've read about pointer arithmetic.", "id": "e50h0cn", "replies": []}, {"body": "To help this make sense.  It would be helpful to print both addresses. All that's happening, is that you're subtracting 2 hexadecimal addresses that are on the stack.\n\n**ex: (ptr2  -> 0x28ff10 ) - ( ptr1 -> 0x28fefc ) = 0x14.**\n\n**0x14 in decimal form is 20.**\n\nAlso note that you're not accessing the value in the address of ptr1/ptr2 in the program. You would do that with the deference operator '\\*'.\n\n    ex: printf(\"%d\\n\",*ptr1); vs printf(\"%x\\n\",ptr1);\n\n\u200b", "id": "e50lvgl", "replies": []}], "title": "[C] How is casting int* to char* related to bytes in this example?"}