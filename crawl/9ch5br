{"url": "https://www.reddit.com/r/learnprogramming/comments/9ch5br/help_with_this_codesignal_challenge/", "text": "[https://app.codesignal.com/company-challenges/mz/zCYv3tuxRE4JajQNY](https://app.codesignal.com/company-challenges/mz/zCYv3tuxRE4JajQNY)\n\nI'm trying to solve this codesignal challenge - I'm passing all of the sample tests, but not 2 of the hidden tests. This is my current code: [https://repl.it/repls/MixedSpecializedJavabytecode](https://repl.it/repls/MixedSpecializedJavabytecode)\n\nEDIT: I'm doing this challenge in Javascript.\n\nSo my main idea is to assign weights to each quest, and then choose the quests with the highest weights until I exceed to timeForQuest time limit. I already realize one problem with my code - I don't account for the possibility of quests that have the same weights, which in my code, would make for duplicate keys. I haven't found a way to handle this - are there any revisions that could be made to keep my code from becoming too inefficient? Or is there a better way to approach the problem? Any help appreciated, thanks.\n\n\u200b\n\nEDIT: Here is the challenge.\n\n[https://imgur.com/a/WRtdAlL](https://imgur.com/a/WRtdAlL)", "score": 1, "comments": [{"body": "It seems you may have included a screenshot of code in your \npost \"[Help with this codesignal challenge...](https://www.reddit.com/r/learnprogramming/comments/9ch5br/help_with_this_codesignal_challenge/)\".\n\nIf so, note that posting screenshots of code is against \n/r/learnprogramming's rules: please **edit** your post to use one of the \n[approved ways of formatting code](https://www.reddit.com/r/learnprogramming/wiki/index#wiki_formatting_code). \n(Do NOT repost your question! Just edit it.)\n\nIf your image is not actually a screenshot of code, feel free to ignore \nthis message. Automoderator cannot distinguish between code screenshots \nand other images.\n\nPlease, *do not contact the moderators* about this message. Your post is still visible to everyone.\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/learnprogramming) if you have any questions or concerns.*", "id": "e5anp8t", "replies": []}, {"body": "Could you use something that allows for duplicates to store your values?  Might be more clunky but it would solve your duplicate key issue.\n\nEDIT: Also, there wasn't much need to post the same question twice... ", "id": "e5aq99i", "replies": [{"body": "I agree. Either allow duplicate keys or use a unique ID for the key.\nDon't worry about performance. The difference won't be noticable", "id": "e5aqfpr", "replies": [{"body": "yeah, a way to uniquely identify the keys has been on my mind, but how do I do that with decimals?  I thought about converting the decimal to a string, and just add whatever 'i' is in that current iteration to the end of the string (after converting i to a string), but then it messes up the sorting.  at that point it would feel too convoluted, but even if I tried that, how would I sort before converting to a string?  or how would I do this?", "id": "e5b06o6", "replies": []}]}]}, {"body": "You had this idea...and then you did what with it, started coding randomly? Adjusted the weights until it started passing tests? That's the exact opposite of what you should be doing. Which is simply: prove your idea works. With a pencil and paper, not code. Once you have a working algorithm, translating it to code is the easy part. But in this case you won't be able to prove the idea works, because it doesn't.\n\nI don't have any idea at all how to lead you to solving this problem on your own. I imagine very few people could actually answer it on their own. Everybody else just learned about it in school or from running into it somewhere else. It is the knapsack problem. This version doesn't even have any variation to it so you should just be able to use the wiki algorithm/pseudocode directly.\n\nhttps://en.wikipedia.org/wiki/Knapsack_problem", "id": "e5ar2vx", "replies": [{"body": "I actually came up with this idea on paper.  I figured consolidating the quests into one value would make things much easier to deal with.  And I didn't adjust the weights until it passed all the tests, I proved to myself that the points weight needs to be slightly higher than the (timeForQuest - time) weight.  And so I chose the weights accordingly.  is there any way to continue my problem with my approach?", "id": "e5b08xf", "replies": [{"body": "I'm not trying to be mean and I probably should have phrased it differently, I'm just saying you didn't figure out whether your solution actually worked before you implemented it. Now you have a solution but it doesn't pass all the tests so you're trying to fix it from halfway when the problem is that the idea won't work to begin with.\n\nNo there isn't any way to make your solution work. No matter how you weigh the elements, you can always create an input that will \"fool\" the weighing scheme. You are trying, as an analogy, to order and then select items by density, or efficiency. (Hopefully that makes sense and is a statement you would agree with.) This is a natural idea but unfortunately there is simply no guarantee that the densest/most efficient element - or any other - is part of the solution. In fact there basically is no solution to this problem other than brute force (considering all possible combinations). But for this specific version of the problem there is so much redundancy involved that dynamic programming can take the complexity down to linear, more or less.", "id": "e5b3tjm", "replies": [{"body": "I guess I don't understand why my weights wouldn't work, because they do in fact work for most of the tests right now.  You pointed me to a wikipedia article, which I skimmed over, but I want to see if my solution could work as well, and I think it can.  I am assigning weights to the quests, and I've gotten good results from my sample tests.  I actually made a modification and now I'm passing 6/7 tests, and I think I'm failing the last test because I haven't found a way to deal with quests that have the same weight (which would make for duplicate keys in my case).  I don't think my test failing has anything to do with my weights.  I guess the easiest way to settle this would be if you gave me an input (making sure that the quests don't have the same weights because again, I haven't gotten around that problem yet) that prove my weights are a problem.  I mean, that's the only thing that would convince me using a weighted system is an objectively wrong way to go about solving this problem, because I honestly don't see the problem with it at the moment.  Also, you can try running my code yourself to see if certain inputs screw it up.", "id": "e5chhd9", "replies": [{"body": "My whole point is that it's not up to me to prove you wrong, *it's up to you to prove you're right*. With *math*. That's how you design algorithms. (And very often it doesn't have to be a formal proof, or anything, it just needs to be a convincing enough description.) You didn't do that, or you wouldn't be stuck trying to get it to work.\n\nTake whatever weighting criteria you are using, construct an element with a high weight, then construct a solution out of only lower weight elements. There are an infinite number of examples. I don't know what modifications you mean you made, so pretend weight is just value/time (a straightforward way to measure time efficiency). Then a quest with a value of 1 and a cost of 1 hour has a weight of 1. A quest with a value of 2 and a cost of 4 hours has a weight of .5. Now if the player has 4 hours to do quests, the optimal solution is to pick the inefficient quest.\n\nWhat if you try a different weight criteria? Then you will be able to construct a different input that breaks it. (Try it *yourself*.) Why is that? I can't explain it better than the link to the Wikipedia page, so you're on your own from here.", "id": "e5csst7", "replies": [{"body": "\"You didn't do that, or you wouldn't be stuck trying to get it to work.\"  I did do that.  But you're assuming that the fact that I'm using weights as opposed to the Wiki conventional method is the reason I'm struggling.  It isn't, because I proved to myself that my weights work.  The problem is not the fact that I'm using weights right now, but rather the fact that I have to deal with DUPLICATE values, which, in my code, makes for duplicate keys (in my map).  THAT is the problem, not the weights.  I am convinced that there is no input that makes my code fail as an effect of me using weights.  Again, the input that's giving me problem right now (I think) is because of the duplicate key situation, and NOT the weights.  I didn't understand your middle paragraph where you seemed to give me some unnecessary description of some sort of input.  I've tried many inputs myself (all of which result in non-equal quest values, because again, I'm still trying to get around that problem of duplicate values efficiently), and all of them pass.  I'm asking you, in order to convince me that using weights is wrong, to give me 1 input that screws up my code (making sure that the quests don't have the same values because again, I haven't gotten around that problem yet).  Just give me two arrays and the expected output.  I guarantee you can't find one that does that, because the simple fact is, my weight system works.  Like I said, I've already tried it myself, and it checks out.  To substantiate your claim that weights shouldn't work, provide me with an input and expected output that makes my code not work.  Also can you look at my code, because you said some things in the above reply that made me think you might not understand my algorithm.\n\n&#x200B;\n\nAlso, just to be perfectly clear - \"You had this idea...and then you did what with it, started coding randomly? Adjusted the weights until it started passing tests?\"  <--- I did not do this.  I did NOT do this.   I proved it to myself (with math) on paper before I ever touched the keyboard.  That's why I'm so confident my weight method is valid. \n\n&#x200B;\n\n&#x200B;", "id": "e5d39xo", "replies": [{"body": "> \"You didn't do that, or you wouldn't be stuck trying to get it to work.\" I did do that.\n\nYou didn't.\n\n> But you're assuming that the fact that I'm using weights as opposed to the Wiki conventional method is the reason I'm struggling.\n\nI'm not assuming it, I deduced it based on the fact that the approach you are stuck on *mathematically cannot work*. (And there isn't anything wrong with using \"conventional\" methods. Trying to solve the problem on your own and investigating your own ideas *judiciously* is a useful approach to learning; willfully ignoring the knowledge of those who came before you just makes you a moron.)\n\n> It isn't, because I proved to myself that my weights work.\n\nI doubt that, since you have written probably a thousand words so far, and have used exactly 0 of them to elaborate your reasoning for why you think your solution should work, or demonstrating your supposed proof. If you would bother to put that bare modicum of effort in, then we could probably point out the misunderstanding.\n\n> The problem is not the fact that I'm using weights right now, but rather the fact that I have to deal with DUPLICATE values, which, in my code, makes for duplicate keys (in my map). THAT is the problem, not the weights. I am convinced that there is no input that makes my code fail as an effect of me using weights. Again, the input that's giving me problem right now (I think) is because of the duplicate key situation, and NOT the weights.\n\nOnce you have decided *how* your algorithm needs to address this situation (ie, once you have an *entire* algorithm, and not just some idea that you *think* might work), it would be trivial to correct the code. For example, do you think that if there are duplicate keys, the algorithm should select all of them? Then use a map that can count duplicate keys. There is such a thing as a multiset or multimap, but for simplicity's sake you can just store lists of values instead of single values. Before adding to the map, you check if the key already exists. If it doesn't, you add a list with one value inside, so instead of looking like `2.1 => [1, 1]`, you would have `2.1 => [[1, 1]]`. If they key does already exist, you add to the list instead, so you get `2.1 => [[1, 1], [1, 1]]`. (You could do a count, instead of a list of values, but then you have to be careful that your system won't end up with the same weight from different values.)\n\n> I didn't understand your middle paragraph where you seemed to give me some unnecessary description of some sort of input.\n\nI gave you a complete description of an input that your algorithm would fail on, with the understanding that you are an adult and can do a small amount of interpretation on your own without needing to be spoon fed like a child.\n\n> I've tried many inputs myself (all of which result in non-equal quest values, because again, I'm still trying to get around that problem of duplicate values efficiently), and all of them pass. I'm asking you, in order to convince me that using weights is wrong, to give me 1 input that screws up my code (making sure that the quests don't have the same values because again, I haven't gotten around that problem yet). Just give me two arrays and the expected output.\n\nBut if you insist on being spoon fed, then here it is.\n\n* \"a quest with a value of 1 and a cost of 1 hour\": `h[0] = 1`, `points[0] = 1`\n* \"A quest with a value of 2 and a cost of 4 hours\": `h[1] = 4`, `points[1] = 2`\n* \"the player has 4 hours to do quests\": `timeForQuests = 4`\n* \"the optimal solution is to pick the inefficient quest\": the expected output is 2.\n\nAgain, I don't know what you changed your code to, when you said you made adjustments to it above, but running the original code from your OP, your algorithm does this:\n\n       questEfficiencyItem([1,4],[1,2],4)\n    Map { 2.1 => [ 1, 1 ], 1.2 => [ 4, 2 ] }\n    => 1\n\nThe wrong answer.\n\n> I guarantee you can't find one that does that, because the simple fact is, my weight system works.\n\nMmm.\n\n> Like I said, I've already tried it myself, and it checks out.\n\nLike *I've* been saying, it doesn't matter what you've *tried*. It matters what you've *proved*.\n\n> Also can you look at my code, because you said some things in the above reply that made me think you might not understand my algorithm.\n\nWhat's happening is that *you* have been defensive from the instant your idea was scrutinized and it's getting in the way of you learning anything.", "id": "e5d5msv", "replies": [{"body": "Ok, yeah even with the modification I made, my code can't handle the input you gave.  I really thought this weight system would work - my core idea was to cleverly consolidate the two factors that determine the result into one, easy-to-work-with number.  I guess I'll just take a look at the solution that has already been devised.  But out of curiosity, do you think this weight idea could work for any input with certain adjustments?  Or is my approach totally off?  Also a bit unrelated, but saying someone has to be \"spoon-fed\" is just an excuse for your unnecessarily complicated explanation.  I agree it wasn't that complicated and I could've put more energy into interpreting it, but seeing as I was focused on explaining other things, saying \"This doesn't work: questEfficiencyItem(\\[1,4\\],\\[1,2\\],4)\" would've been much more clear and easy to understand.  Some messages require more words to convey, but in this case, explaining so even a \"child\" could understand is the clearest and fastest way to get across information.  But anyway, thanks for the help.   ", "id": "e5d74va", "replies": []}]}]}]}]}]}]}]}], "title": "Help with this codesignal challenge..."}