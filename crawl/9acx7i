{"url": "https://www.reddit.com/r/learnprogramming/comments/9acx7i/how_do_i_learn_to_write_modular_code/", "text": "I have been looking at lots of open source projects and I see they're written very modularly with code separated into folders and lots of files inside those folders as well.\n\nAnother thing is that the strings are stored in different files altogether which makes it easier to write themes and translations.\n\nMy question is, what common practices should be followed to write modular code?\n\nAs in, what file structure to use and when should a function be written in a separate file and imported, etc.\n\nI have tried looking for tutorials on how to write modular code but couldn't find much. Any links to tutorials and blogs would be great too.", "score": 12, "comments": [{"body": "I am not sure if I know any good tutorial on modular code or not, but lot of it comes from practice. You are definitely on right track where you have started observing/reading some good code. My personal experience is that:\n\n* You will learn a lot of it when you work on real world projects, with some senior developers. Get your code reviewed by someone experienced and he/she will tell you why you should write a code in particular way.\n* Learn about some good concepts such as DRY, KISS, Separation of concern etc. These concepts can guide you write modular code.\n* I believe the folder structure you are talking about comes from following web frameworks. Usually if you pick up any good web framework, it will generate some initial code for you along with place holders/folders. You can understand this folder structure and put down your code in relevant package.\n* I read Pragmatic Programmer sometime back. I think the book has some really good guidelines on how should you develop your code. You can also look at other popular books such code complete, refactoring etc.", "id": "e4um7xy", "replies": []}, {"body": "This might be a controversial suggestion, but I'd recommend trying to create a simple C++ project, perhaps using an external library. C++ as a language is high level enough for you to be able to create complex apps with well abstracted code, and low level enough for the way you organise code in files to affect compilation and even runtime overhead.\n\nIllustrating the former: you could dump everything in one monolithic file; the most procedural way of doing it. Surprisingly, the biggest cost you'll pay is that the entire app will need to be recompiled every time you change any part of the source. This is because the compiler translates every unit into an object file (identical to an assembler's output object file), all of which are then passed to the linker, which replaces placeholder addresses with real ones, and creates the final executable.\n\nSo you split the code up into various files, such that related code is in one file, thereby reducing the chances of other files needing to be changed / compiled when you affect one module. This lines up nicely with writing one class definition per file, for the pure OOP code at least. Most environments are smart enough to skip recompiling unchanged code, effectively using the previous build's object files. (This is precisely why the compilation process is split up into two parts, and since assembly days.)\n\nNow it's time to look at headers and `include`s: since the compiler doesn't need the full definition of a function to be able to produce a translation unit's (.cpp) object file (.o), and doesn't need to know anything about types whose pointers/references are used but not the whole type, etc; so you optimise headers for all that: use forward declarations, minimise `#include`s in headers, define all functions in separate `.cpp` files, etc, and you get semantically the same code but orders of magnitude faster compilation. This is because an `#include` is basically just shorthand for copy-pasting that entire header file into this one. So it's best to minimise each header file's overhead, and to include as few other headers in header files as possible.\n\nThen you learn about precompiled headers: \"special\" files that an IDE can cache unchanged versions of, so you `#include` all common library code etc there, further improving compilation time.\n\nAs you keep going, all this seemingly C++ specific file-organising knowledge translates very well to pretty much any other higher level language too.", "id": "e4uozj7", "replies": [{"body": "Not OP, but do you know of any projects on somewhere like github I could glance at with examples of this type of segmenting? I'm trying to learn the habit of better code organization for projects that are more than bite-sized and I think I get the general gist of what you're saying, but it'd help a lot if I could look at examples of professional-grade projects where this is done.", "id": "e4upvp0", "replies": [{"body": "Try https://github.com/soxueren/EpicGames-UnrealEngine", "id": "e4uqqcv", "replies": [{"body": "Thanks. :) I'll try that.", "id": "e4uqx0e", "replies": []}]}]}]}, {"body": "Read design patterns book that will help lot", "id": "e4vcmqi", "replies": []}, {"body": "I'm fairly new to all this myself, but my experience so far is that one of the driving factors in modular code is to make it readable/understandable. 30 files that are 50 lines long are much easier to read than one file that's 1500 lines long.\n\nAnother factor in modular code is separation of concerns. Think of it somewhat like separating text into paragraphs: each paragraph focuses on one topic, concept, or point.\n\nAlso, maybe look into MVC pattern and see how far down the rabbit hole you end up.", "id": "e4ukq2x", "replies": []}, {"body": "That's way to broad of a question. It will be vastly different from one project to another and depends on the requirements the user/client has for the project. There are so many different variants and tbh I don't find any of them satisfying.\n\nInternationalization alone is considered an unsolved problem. ([Computerphile commentary](https://www.youtube.com/watch?v=0j74jcxSunY))\n\nThere are no final statements anyone could make and say _\"this is the best design/decision/etc. regarding i18n and theming or that other thing!\"_. As long as whatever you do works for your current project you are good.\n\nIf your question is actually aimed more at the technical side of things, for example how to design units of code like classes and methods or aimed at one specific problem in one specific circumstance I could maybe give a better answer.", "id": "e4upbso", "replies": []}, {"body": "Two broad strategies for your directory hierarchy: you can either group similar code together, or you can group functionally-related code together. For example, if you have a web app:\n\n    # similar code \n    src/\n      models/\n        invoice_model.rb\n        user_model.rb\n      templates/\n        invoice_template.haml\n        user_template.haml\n\n    # functional grouping\n    src/\n      invoices/\n        invoice_model.rb\n        invoice_template.haml\n      users/\n        user_model.rb\n        user_template.haml\n\nI tend to prefer the latter. \n\n---\n\nA nice way to handle modularity is to place code at the lowest sensible level. If you only use your string-formatting function in one class, keep it in that class. As you start using it elsewhere, move it to a more general place. \n\n> Another thing is that the strings are stored in different files altogether which makes it easier to write themes and translations.\n\nIt's good to keep data separate from code, within reason of course. ", "id": "e4v1yek", "replies": []}], "title": "How do I learn to write modular code?"}