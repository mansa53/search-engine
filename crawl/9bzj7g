{"url": "https://www.reddit.com/r/learnprogramming/comments/9bzj7g/whats_the_point_of_merge_sort/", "text": "Isn't it just a more convoluted way of doing a selection sort? I'm very new to this so I probably won't understand why dividing it up and up over and over is good, so please don't take this as an insult or something.", "score": 1, "comments": [{"body": "Merge sort is faster than selection sort.\n\n* Selection sort\tO(n2)\n* Merge sort\tO(n log n)\n\nhttps://www.cpp.edu/~ftang/courses/CS241/notes/sorting.htm\n\n\nhttps://www.titrias.com/sorting-algorithms-comparison-insertion-sort-vs-merge-sort/\n", "id": "e56x93u", "replies": []}, {"body": "selection sort will be ideal for smaller scale arrays but merge sort comes into with larger ones", "id": "e56xssz", "replies": []}, {"body": "For selection sort you have to look at everything you have in the array that isn't sorted to find the smallest.  You have to do this for each item in the array you want to sort.  The number of times you have to look for the smallest is n,  and the number of things you have to look at to find the smallest averages to n/2 (starts at n, but ends at 1 as the amount of unsorted items gets smaller each iteration).  Overall the complexity is n*(n/2) which is O(n^2) as we don't care about constants.\n\n\nMerge sort works off the concept that it's easier to decide which is the smallest element if you only have to compare two items rather than all of them.  So you keep splitting your list in half until you only have one item in each side.  It's easy to sort a list with one item in it because it's inherently already sorted.  You can then merge it back with what you split it from in the previous step, so now you only have to compare 2 things which is easy as well.  Next time you merge it gets a bit harder because now there are two things in each side, but because you know each half is already sorted you only have to compare the smallest item in each side to determine the smallest item when they are combined.  You keep doing this until you get back to the original array and it's now fully sorted.\n\nThe complexity is a bit less intuitive here.  You are splitting the array a bunch and then doing a bunch of smaller comparisons.  At each stage you are halving the size of your array so the number of times you can half it before you get to one item is log2(n).  At each \"level\" of splitting, the total number of comparisons you do adds up to n.  The first time when you merge the lists of size 1, you are doing n/2 merges, and each merge takes 2 steps to get a fully merged list.  In the final stage when you are merging your 2 lists into the final sorted array you are doing 1 merge that takes n steps to fully merge the list.  It works out that you are doing n steps in total at each level of merging, so the complexity is log2(n)*n or O(nlogn).\n\nIn practice the merge sort algorithm has a larger constant component so at small input sizes selection sort is faster.  When you get to bigger input sizes though the reduced time complexity of merge sort makes all the difference. https://www.titrias.com/sorting-algorithms-comparison-insertion-sort-vs-merge-sort/", "id": "e57eb35", "replies": [{"body": "Oh ok, thanks! I knew it was considered faster but I didn't understand why, but this explanation makes sense now. Thanks!", "id": "e57fvg5", "replies": [{"body": "It's not \"considered\" faster, it *is asymptotically faster*.", "id": "e58v1wx", "replies": []}]}]}], "title": "What's the point of merge sort?"}