{"url": "https://www.reddit.com/r/learnprogramming/comments/9cccnk/how_popular_is_pseudocode/", "text": "I find that I write a lot of pseudo-code (a large part of which doesn't make its way to actual code) while I'm brainstorming. I outline a whole program with this and try to create a grammar for the task at hand. Like thinking up of a \"mini-grammar\" for it. I don't draw diagrams except a tree occasionally, just write stuff like\n\n  * Check if the indexed strings mach word-to-word\n    * If they do delete the previous one\n    *  If one is a subset or super-set of other merge them\n\n\n\nIs it pat of the normal programming process? Is there a formal way of doing it? ", "score": 25, "comments": [{"body": "Yes, making a plan before you start writing code saves a lot of time otherwise spent cleaning up mistakes.", "id": "e59m74d", "replies": [{"body": "A lot of the times I put down statements that I don't know how to implement. ", "id": "e59qiif", "replies": [{"body": "Divide thoes statements into substatements :)", "id": "e59qkgs", "replies": [{"body": "Problem solving is just solving smaller divisions of problems all the way down", "id": "e59rsdc", "replies": []}]}]}, {"body": "Yup, but don't spend too much time planning otherwise you end up in analysis-paralysis or a waterfall design that is not easy to change.\n\nFrom my experience, as an architect, a little up front design with small iterative sprints and a checkin after works far better. It allows us to be agile and adjust to a changing landscape. Too much up front design and a bunch of set in stone requirements that can't change often results in building something no one wants. I've seen many projects early in my career where teams did 6 months of design, 2 years of coding only to finally show the customer the result and find out that is NOT what the customer wanted. So we now work in small 2 week iterations with a small deliverable to the customer at the end, if we are off track we've only lost 2 weeks, not two years.", "id": "e5a65at", "replies": []}]}, {"body": "We were instructed to practice it more than we think we should because there will most likely come a day when good psuedo-coding skills will really be necessary. ", "id": "e59m7yy", "replies": []}, {"body": "It can be helpful when you're a beginner, but once you're fairly comfortable with a language then it starts losing its usefulness. The big problem is that you can't run pseudocode to see if it's right. I mean, why is it easier to write\n\n> Check if the indexed strings mach word-to-word\n\nthan\n\n    if (a[i].equals(b[i]))\n\nor\n\n> If they do delete the previous one\n\nthan\n\n    a.remove(i-1)\n?", "id": "e59qpyh", "replies": [{"body": "Because \"the previous one\" encodes more useful semantics than \"the element at index i - 1\". The latter requires you to keep more context in your head & translate through more layers of abstraction.\n\nOr, to answer your question from another angle: the same reason we use high-level languages instead of Assembler. ", "id": "e59t191", "replies": []}]}, {"body": "The popularity of it? Very popular, because if you don't have some plan it makes programming a lot longer for projects. ", "id": "e59ocmu", "replies": []}, {"body": "Python is a very popular language! ", "id": "e59xsym", "replies": []}, {"body": "When I started, it helped. \nStill helps on complex problems. \nOvertime, you\u2019ll be able to have a mental model of what\u2019s needed without writing it. \nEssentially you\u2019ll skip to coding and testing right away. ", "id": "e59mfcn", "replies": []}, {"body": "I still do this quite a bit. One of my go-tos if I'm in a hurry is to start with a shell of a program, and use comments to pseudo-code the logic. Not without it's drawbacks, but on the whole I'd end up with a decent amount of internal documentation for the next guy.", "id": "e59uhrj", "replies": []}, {"body": "You should always be thinking pseudo-code to solve problems, then focus on implementing it. \n\nAlways try and separate language from logic, train your brain to do so. That\u2019ll help learn new languages faster in the long run.\n", "id": "e59ot35", "replies": []}, {"body": "Every project.", "id": "e59m83m", "replies": []}, {"body": "I don't usually actually write out pseudocode most of the time, unless the algorithm I'm trying to figure out is really complex. I prefer either simple lists of ideas to get the though process going, or drawing out diagrams. For the latter, I've always found pictures to be one of the best ways to express ideas. ", "id": "e59pghj", "replies": []}, {"body": "If you don't want to be stuck on an algorithm for several hours, the best way to solve your problem is to run through the algorithm on paper, which means you have some sort of idea in your head about what might work, hence the need for easy to read pseudo code. ", "id": "e59pzh3", "replies": []}, {"body": "I use it when I have very complicated logic or when I have a big task that I haven't broken down yet.\n\nI focus on the Transaction Script pattern to start then find common elements for functions and make it object oriented only if those elements could be used elsewhere for future features.", "id": "e59rylh", "replies": []}, {"body": "I only use it when I have to something is very complicated and requires many steps. Most recently I had to calculate a sales persons commission that had a ton of edge cases. So writing it out helped a ton", "id": "e59slgq", "replies": []}, {"body": "I kind of just use Python as pseudocode mostly, though I\u2019ll throw in methods that don\u2019t exist as standins.", "id": "e5a0oww", "replies": []}, {"body": "Totally. Writing and planning really help me to make my ideas concrete and stake out some forward progress in finishing a logic puzzle. Writing out decision trees like this is something I especially have to do when there are multiple states in play and so have to make sure all cases are covered. It also helps serve as a guide as I\u2019m coding the details\u2014I\u2019ve worked out the overall structure, now step through the branches and implement the details.\n\nThe pseudo code rarely resembles the line-by-line finished result. I saw that technique in school, but I think it\u2019s more useful when you don\u2019t know your programming language very well. \n\nOn a related note: I\u2019ve gotten a lot of use out of rubberducking in a notes file, just describing a tricky problem in conversational sentences as if I were describing it to someone who was going to help me. It helps me get valuable insight into the problem almost every time. ", "id": "e5a5iow", "replies": []}, {"body": "Been in the industry over 15 years, yes it's very common. Different people have tried standardizing pseudo-code, but at the end of the day whatever makes you productive is what matters.", "id": "e5a60bg", "replies": []}, {"body": "I don't really use pseudocode. I sometimes write in function names without implementing them first but I figure it's about the same amount of time to write pseudocode as real code, so if i do any kind of outline it'll be real code in the language i'm working in.", "id": "e5a7p05", "replies": []}, {"body": "I do this a lot. It helps me when solving complex problems. Typically I writing out the class headers and and functions necessary to solve that particular problem. Then after I figure out that I have reasonably covered the problem then I start coding. However, its difficult to say sometimes (maybe I don't have enough experience) whether I have written the necessary function and class definitions in enough detail.", "id": "e5ab20a", "replies": []}, {"body": "I'd say Python is pretty popular, yes. ", "id": "e5ac1c7", "replies": []}, {"body": "I used it when I started. Now not so much for simple problems. Use UML for complex ones. Some tools will generate code based on UML which helps you start coding.", "id": "e5ag3ug", "replies": []}, {"body": "I would think it's as \"normal\" as you want it to be. If it works for you, that's what matters.\n\nI find it works sometimes for me. Sometimes it's too abstract and my focus just disintegrates. For me, usually the more concrete of something I can fiddle with, the quicker/easier I can grasp how it works.\n\nBut sometimes I'm just trying to wrap my head around a complex solution and in that case, pseudo can be essential to making a rough outline of how to work through it, rather than getting distracted in redlines and syntax errors.", "id": "e5aqvb8", "replies": []}, {"body": "I deploy psuedo code directly into master", "id": "e59v3ch", "replies": []}, {"body": "Good code is 75 time spent on pseudo. 15 implementing. 10 bugfix. Bad code is No pseudo: 100 on implementing; and 200 on bugfixing. And then somebody asks you what is it's time complexity.", "id": "e59pvsb", "replies": [{"body": "75% of your time in pseudo? I don't know about that... I'd like 10 max, if anything.", "id": "e59sny5", "replies": [{"body": "> while I'm brainstorming\n\nFor me pseudo phase includes studying data, reading, trying to understand relevant components of problem. Searching for the actual root of the problem rather than the cause of the symptom. \n\nAfter connecting the dots, and solution path, i've got [the pseudo / object graph](https://pbs.twimg.com/media/DEXfbZ8W0AAOSXe.jpg). Problems where i spend 10 or less on pseudo i assume i already understand what's going on and i don't consider \"problems\". \n\nI know real life is more make do, and keep the boat floating. But i find lifting the water less effective than finding the missing bulkhead. \n\nEDIT: I might be a ruminant rather then a chameleon.", "id": "e5a2zzt", "replies": []}, {"body": "Only 10% of your time is spent planning? How do you get anything done? ", "id": "e59t850", "replies": [{"body": "I don't consider planning equal to pseudocode.\n\nThose are two separate things", "id": "e59tbwh", "replies": [{"body": "It's pretty clear from context that \"pseudocode\" in this thread is a synonym for \"planning\" (or \"design\"). You'll note the person above you didn't carve out separate time for planning. ", "id": "e59tm9o", "replies": []}]}]}]}]}], "title": "How popular is pseudo-code?"}