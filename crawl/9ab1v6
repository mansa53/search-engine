{"url": "https://www.reddit.com/r/learnprogramming/comments/9ab1v6/c_bit_manipulation_on_file_size_need_help_to/", "text": "Hey.\n\nI've this piece of code I don't fully understand, since I have little experience with bit manipulation. The code mark files inside an archive as compressed or not based on the archive header, unless the if check below is true. Then it's the opposite of the archive.\n\n[Archive File Format Specs](http://en.uesp.net/wiki/Tes4Mod:BSA_File_Format#File_Record)\n\n    if ((size & (1 << 30)) != 0)\n    {\n        comp = !comp;\n        size ^= 1 << 30;\n    }\n\nUsed [HERE](https://github.com/AlexxEG/BSA_Browser/blob/f1e73bc13a6ec22171eb0c24875718e63f892208/Sharp.BSA.BA2/BSAUtil/BSA.cs#L136)\n\nSo `comp` is a boolean determining if the archive is compressed. And `size` is the current file size inside the archive in bytes.\n\nWhat I'm wondering is how and why is `size` changed on the fourth line?\n\nAlso there is this line:\n\n    ulong filesz = this.Size & 0x3fffffff;\n\nUsed [HERE](https://github.com/AlexxEG/BSA_Browser/blob/f1e73bc13a6ec22171eb0c24875718e63f892208/Sharp.BSA.BA2/BSAUtil/BSAFileEntry.cs#L57)\n\nWhy is it doing a bitwise operation on the file size?\n\nSorry if my question is unclear, hopefully I'm making sense. Thanks!", "score": 1, "comments": [{"body": ">What I'm wondering is how and why is size changed on the fourth line?\n\nIt toggles the bit that marks the file as compressed or not compressed. But since the block is only entered if that bit is 1, the end result is that the bit is changed to 0. After that (I assume) `size` contains the actual size of the file.\n\n>Why is it doing a bitwise operation on the file size?\n\n`0x3fffffff` is `00111111111111111111111111111111` in binary, which means that the bitwise operation essentially changes the first two bits of `this.Size` to 0 and leaves the other bits untouched.", "id": "e4u2xte", "replies": [{"body": "Am I right then that the `size` variable before the bitwise operation isn't the actual file size?\n\nAlso on the second question, is it not possible for the 2 first bits to be a part of the actual number, if that makes sense?\n\nThanks for the help!", "id": "e4u3n5i", "replies": []}]}, {"body": "    if ((size & (1 << 30)) != 0)\nThis checks to see if the 30th bit in `size` is set to 1.\n\n-------\n\n    size ^= 1 << 30;\n\nThis toggles the value of `size`'s 30th bit.\n\n--------\n\n    this.Size & 0x3fffffff\nThis returns the value of the `size`without the 30th and 31st bit values (an unsigned long is 32 bits and 0x3fffffff is 30 consecutive 1's in binary).", "id": "e4u3ikz", "replies": [{"body": "Thanks!\n\nThis may be a dumb question, but couldn't any of those bits be used as a part of the actual decimal value?", "id": "e4u3ryj", "replies": [{"body": "If I understand your question correctly, I believe the true size of each individual file would need to be limited to less than or equal to 0x3fffffff bytes.", "id": "e4u5bni", "replies": [{"body": "That makes sense. Thanks, you've been helpful.", "id": "e4u5lhl", "replies": [{"body": "No problem, glad I could help", "id": "e4u5ztd", "replies": []}]}]}]}]}], "title": "[C#] Bit manipulation on file size. Need help to understand"}