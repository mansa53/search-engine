{"url": "https://www.reddit.com/r/learnprogramming/comments/9ahp0q/help_making_a_plan_for_learning_to_program/", "text": "Right now, I have a BSc in Biochemistry and am working in a government job with no real options for progression. Thus, I need a career change. In my last semesters of Biochem, I took two introductory CS classes and did reasonably well. I also took a discrete math class and barely scraped a pass; so that's worrying.\n\nMy CS classes taught me the basics of C++ including:\n\n* Data Structures (Lists, Vectors, Maps etc)\n* Basic Sorting Algorithms (Merge Sort, Quick Sort, Heap Sort, etc)\n* Very basic trees and recursion\n* OOP as far as operator overloading, but not inheritance or polymorphism.\n\nI have taught myself some Java too.\n\nI want to continue with learning the details of programming, in a generic sense and specifics of C++ as well. But I'm not exactly sure where to go next. It'd be a huge help if someone could help me make a self-study plan for developing the essential skills I need to become a competent C++ programmer. Here are my thoughts so far, as a stream of consciousness:\n\n* GitHub\n* GUI's\n* Inheritance and Polymorphism\n* SQL\n* Writing Makefiles\n* The Static keyword\n* Lambda Expressions\n* What are mutable and immutable datatypes?\n* Somehow improve my algorithmic thinking\n\nThat's everything I can think of. It'd be a big help if someone could help improve and organize my list so I can set some good goals for myself.\n\nAlso, I know completed projects are useful for interviews; so I'll need some of those too. Does anyone have any advice or suggestions for projects? Are console applications ok? Do they have to be super technical and/or original?", "score": 8, "comments": [{"body": "To all following commenters: please, do not bring up the old circlejerk \njokes/memes about recursion (\"Understanding recursion...\", \"This is \nrecursion...\", etc.). We've all heard them n+2 too many times.\n\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/learnprogramming) if you have any questions or concerns.*", "id": "e4vh1dz", "replies": []}, {"body": "Here's a goal to set: practice, practice, practice. Learn something new every day. If you are only reading code and reading how to code, you will not learn. You have to implement code yourself. \n\nI took discrete math, scraped by as well (C- in course). I would not be too alarmed, not knowing travel salesperson program, djikstra's algo, all of this won't have a negative affect. Of course knowing this would help but just continue to learn.\n\nComputer Science is a field that grows and changes every single day. You wouldn't be doing yourself a solid if you don't practice a lot.", "id": "e4vni5o", "replies": [{"body": "I try to practice, and I agree, I makes a huge difference. But I'm at a stage now where I feel like I'm using the same things over and over. This is good, because it's essential stuff that I'm practicing, but I also feel like I've done the basics to death and it's time to move on to more advanced concepts.\n\nI like to think that a good performance in discrete isn't essential. I did find it interesting and I did ok in the exams, but the assignments killed me. We survived and that's the most important thing! Have you taken discrete 2? Is it equally difficult?", "id": "e4vsf83", "replies": [{"body": "My school does not offer a discrete 2 so we cramp everything into one discrete course. Discrete itself can be tough or easy. It all depends on the person and how much time they are putting into that one course.\n\nSince you've got the basics down, why not start a new project? Example, I have the basics down on reactjs and web apis and plan on doing something with the spotify api and react maybe even include a rasberry pi. It's all about what you're passionate about. You can know your shit on algorithms and big o notation but if you are doing something you hate, you won't grow. \n\nPeople can argue that knowing all this information can get you a good job, a job that can pay for a lot but at the end of the day.. do something you love. I like the saying \"do what you love and your job is basically a hobby... eager to wake up everyday.\"", "id": "e4vurq5", "replies": []}]}]}, {"body": "Other users should correct me if I'm wrong but normally when I see C++ jobs they're associated with a specific kind of application development, like embedded systems, implementation of communication protocols or game engine development, so it maybe a good idea to check for which kind of c++ jobs there are around you and try to understand more about the subjects in which you'll be working since those topics (networking, os, computer graphics) are covered in a computer science degree.\n\n&#x200B;", "id": "e4vnxoc", "replies": []}, {"body": "I feel that originality is less important than technicality. Assuming you have the discipline to work through the problem yourself rather than look at the solution and saying you understand as you copy the code. ", "id": "e4vjoxo", "replies": []}, {"body": "If you're dead set on C++ development, you should read all three of Scott Meyer's *Effective C++* books. Why C++, though? If it's just that that's what you learned at school, I think an upfront investment in a better designed language will pay off with less frustrating work.", "id": "e4vl5xe", "replies": [{"body": "Thank you for the recommendation! I'll take a look around my local bookstores and see if I can find it.\n\nI just like C++. I guess I'm biased because it was my first programming language, but I kind of like the complexity of it. Sort of makes it thrilling to me, even if it can be quite frustrating.\n\nWhat other language would you recommend?", "id": "e4vs1lz", "replies": [{"body": "It depends on what kinds of problems you want to work on. \n\n- Python is my default, FWIW, but that's mostly a historical accident. It's good for just about anything except systems-level programming\n\n- For learning good software design, clojure was great\n\n- Go is very simple and fast\n\n- OCaml has an elaborate type system, but mostly manages to keep that out of the way of beginners", "id": "e4vsfw9", "replies": []}]}]}, {"body": "Thoughts:  \n\n* Learn Git first and use it for all your projects. (Don't want your projects public? Use Bitbucket or Gitlab instead of Github, they do the same thing)  \nLearn how to create, commit, push, and pull first. Then learn how to use a git ignore file, how to branch, and how to merge branches.\n* I would focus on either learning one language(C++, SQL) at a time. Integrating SQL into code can be quite difficult if you don't *know both*.\n* For SQL, learn how to do basic SQL statements, such as create, update, delete, select.  \nIf you want to go further, learn about data normalization, relational mapping, and ETL(Extract, transform, load)  \n* I would also recommend reading about software design patterns if you didn't already.  \n* Algorithms are use specific and I would use them when I want them and not before. Knowing when to use an algorithm is gained with experience, I honestly don't know what to recommend asides from working though examples.\n* My advice for projects is to make what you want.  \nDon't worry about originality, if you want to make something that has been done a thousand times before then do it.  \nAnything goes, just make sure you don't get bogged down waiting for the perfect app idea to come floating into your head. If you get stuck look up some programs to make.", "id": "e4vnsnp", "replies": []}, {"body": "To improve your problem solving ability, try doing at least 1 Project Euler task a day. \n\nCheck a site like Glassdoor for a feel of the programming jobs in your area and focus on developing the skills of a job you'd like.", "id": "e4w07js", "replies": []}], "title": "Help making a plan for learning to program"}