{"url": "https://www.reddit.com/r/learnprogramming/comments/9b02mc/trying_to_implement_a_set_data_structure_in_java/", "text": "The way it works is it chains together a bunch of predicates every time the user tries to insert an element. Then, when checking if the set contains the element, we evaluate all of the predicates in a single go (i.e. pred1.or(pred2...etc)  \n\nCurrently, I've implemented a few of the basic features (think add, remove, intersection, union, etc), but I'm having trouble thinking of a way to implement it in such a way that it's iterable. Any thoughts?   \n\nFor reference, here is what I have so far. I've also created some [unit tests](https://github.com/forsythe/PredicateSet/tree/master/src).\n    \n    import java.util.Collection;\n    import java.util.function.Predicate;\n    \n    public class PredicateSet<E> {\n    \n        private Predicate<E> rootPredicate = e -> false;\n        private int size = 0;\n    \n        public int size() { return size; }\n    \n        public boolean isEmpty() { return size == 0; }\n    \n        public boolean contains(Object o) {\n            try {\n                return rootPredicate.test((E) o);\n            } catch (ClassCastException cce) {\n                return false;\n            }\n        }\n    \n        public boolean add(E e) {\n            if (contains(e))\n                return false;\n            Predicate<E> newPredicate = e::equals;\n            rootPredicate = newPredicate.or(rootPredicate);\n            size++;\n            return true;\n        }\n    \n        public boolean remove(Object o) {\n            try {\n                if (!contains(o))\n                    return false;\n            } catch (ClassCastException cce) {\n                return false;\n            }\n            E e = (E) o;\n            Predicate<E> newPredicate = e::equals;\n            rootPredicate = newPredicate.negate().and(rootPredicate);\n            size--;\n            return true;\n        }\n    \n        public boolean containsAll(Collection<? extends E> c) {\n            return c.stream().allMatch(this::contains);\n        }\n    \n        public boolean addAll(Collection<? extends E> c) {\n            var changed = false;\n            for (E e : c) {\n                if (add(e)) {\n                    changed = true;\n                }\n            }\n            return changed;\n        }\n    \n        public boolean removeAll(Collection<? extends E> c) {\n            var changed = false;\n            for (E e : c) {\n                if (remove(e)) {\n                    changed = true;\n                }\n            }\n            return changed;\n        }\n    \n        public boolean intersect(Collection<? extends E> c) {\n            PredicateSet<E> intersection = new PredicateSet<>();\n    \n            for (var x : c) {\n                try {\n                    if (contains(x)) {\n                        intersection.add(x);\n                    }\n                } catch (ClassCastException ignored) {\n                }\n            }\n            var changed = this.size != intersection.size;\n    \n            this.rootPredicate = intersection.rootPredicate;\n            this.size = intersection.size;\n    \n            return changed;\n        }\n    \n        public boolean setMinus(Collection<? extends E> c) {\n    \n            var changed = false;\n            for (var x : c) {\n                try {\n                    if (remove(x)) {\n                        changed = true;\n                    }\n                } catch (ClassCastException ignored) {\n                }\n            }\n            return changed;\n        }\n    \n        public boolean union(Collection<? extends E> c) {\n            var changed = false;\n            for (var x : c) {\n                try {\n                    if (add(x)) {\n                        changed = true;\n                    }\n                } catch (ClassCastException ignored) {\n                }\n            }\n            return changed;\n        }\n    \n        public void clear() {\n            this.size = 0;\n            rootPredicate = e -> false;\n        }\n    }    \n\nSidenote: there's no practical reason for this, I'm trying it for fun only", "score": 1, "comments": [{"body": "I don't think it'll be possible.  The Predicate interface is one-way...once you put something into it, there's no way to get it back out.  You only capture the equals method of your elements, so there's no way back that way.  Actually, I'm not sure how it works at all...you capture `e::equals` method, but how does that manage to find and compare the `e` of another instance?\n\nFunctional programming is hard.", "id": "e4zcpmg", "replies": [{"body": "About the new predicate, what I have is equivalent to \n\n    Predicate<E> newPredicate = obj -> {\n                return e.equals(obj);\n            };\n\nThat way, anytime I evaluate the predicate, I'm checking if it equals the \"saved\" object. Also, I agree, functional programming is hard.", "id": "e4zczeh", "replies": []}, {"body": "Maybe you can make it work by having a negative predicate (X is *not* in the set) and putting new predicates at the beginning rather than that end.", "id": "e4zf57w", "replies": [{"body": "Building on this approach, how would I retrieve a list of the objects inside the predicates ? (e.g. so the user can use a for each loop to iterate over the elements)", "id": "e4ziaqs", "replies": [{"body": "If all a predicate can do is answer the question \"Is X a member of the set\" then you can't (this is true of the mathematical sets as well. It is not assumed there is a way to enumerate the members of a set or even get a single unknown element).\n\nThis is doubly true if the predicate applies to a multitude of items. Consider a set that contains all words that start with the letter A. This could be done as\n\n    set.addPredicate(fn x => x.startsWith(\"A\"))\n\nIn order to enumerate the items in the set you *must* have a universe of entities over which the predicate can be applied (or else you quickly get into Russell's paradox and your who system falls apart).", "id": "e4zj7cu", "replies": [{"body": "That example makes sense, thanks. I'm curious though, for functional languages, is it possible to retrieve the items from a set? If so, how is it implemented?", "id": "e4zjg4e", "replies": [{"body": "You can look at how F# did it in [their implementation of Set](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.set%5B't%5D-class-%5Bfsharp%5D).  The docs say it's a binary tree under the covers.", "id": "e4zjulj", "replies": [{"body": "This looks pretty promising, thanks!", "id": "e4zk0nj", "replies": []}]}]}]}]}]}]}], "title": "Trying to implement a Set data structure in Java using only Predicates. Need help with implementing Set interface with iterators"}