{"url": "https://www.reddit.com/r/learnprogramming/comments/9aaecx/why_is_perl_so_hated/", "text": "I've always heard bad things about it, usually having something to do with the Regex system, but after using it for some text processing, I can't find many problems. What's the source of all of the hatred?", "score": 10, "comments": [{"body": "Most hate for Perl is based on myth and prejudice.\n\nMyths:\n\n1. Perl's code is always ugly. Like any language code prettiness is subjective and can easily be make pretty or ugly by the author.\n2. Perl is old. Perl has been around a long time, but it's still being actively developed. That's not old, that's mature and battle tested.\n\nFacts:\n\n1. Perl's CPAN library has over 150,000 ready to use libraries. More than most other comparable languages. A huge time saver.\n2. Perl was the go to language during the first Internet boom. At that time programmers were in such demand than a lot of less skilled ones were hired, who produced poor code. People judge Perl on that code to this day.\n3. Perl's chief architect, Larry Wall, is a linguist. He designed Perl to be expressive like a human language, there's more than one way to express a thought. This is the reverse Python's one way approach, and the everything is an object approach of Ruby.\n4. You can find something to hate about any language, but this is not constructive.", "id": "e4v0k1p", "replies": [{"body": "I love Perl (and hate it, like just about every language I've ever used), but let's be honest. It's 2018 and Perl 5 [doesn't have an object system in the core](https://perldoc.perl.org/perlootut.html) beyond \"well, a package has some syntactic sugar that makes it look kind of like an object.\" It's 2018 and [formal, named parameter passing is still an experimental feature](https://perldoc.perl.org/perlsub.html#Signatures) that, even when enabled, doesn't support much of what modern programmers expect. It's 2018 and the `$foo`, `$foo[7]`, `$foo{seven}` are all different variables (`$foo`, `@foo` and `%foo` in their non-indexed forms, respectively) thing, that we knew was a terrible idea two decades ago, is still true.\n\nIt's also the case that Perl made some very bad decisions which have haunted it, such as making source filters core. This has lead to some of the most unmaintainable disasters that any language has ever suffered--actually worse than C macros!\n\nThat being said, **I still use perl every day**, and I find that once I teach people how to use it as a command-line tool they're astounded and thrilled at how much more power they have on the command-line than they ever thought they did. It's just not the right tool for the high-level programming world that it used to be.\n\nPerl 6 is another story. I love about 85% of Perl 6, and wish that every language designer in the world was forced to learn it (and Haskell and Smalltalk) before they were allowed to design their first language. But I'm not sure it will ever be capable of supporting the kind of easy slinging that Perl 5 was famous for. It's just got too many sharp edges and too much cognitive overhead in writing even relatively simple code.\n", "id": "e4wasol", "replies": [{"body": "> It's just not the right tool for the high-level programming world that it used to be.\n\nIt can be, as long as you consider [Perl as the VM, and CPAN as the language](https://shadow.cat/blog/matt-s-trout/but-i-cant-use-cpan/).", "id": "e4wimo6", "replies": [{"body": "What a piece of trash article. Seriously, calling Unix an IDE, and Perl a VM? Have we all been reduced to incoherent techno-babble? I would expect better from an ITT grad with a degree in Classic ASP.", "id": "e4wj7ai", "replies": [{"body": "The quote is not from him, and you obviously missed the point.", "id": "e4wl7ar", "replies": []}, {"body": "Its mst, you're gonna hate it regardless of any good arguments presented.\n\nThe difference is between \"calling it a\" and \"treating it like a\".\n\nUnix dev's don't need an integrated toolbox like VisualStudio, their operating system comes with development tools they need, their operating system *is* their integrated toolbox. Hence, in terms of \"what you do with it\", \"Unix\" can very much function in the same role an \"IDE\" does on other platforms.\n\nThe same argument is made for \"CPAN is the language\", its not literally \"the language\", but it very much is a large collection of grammar in which we use to write much of our code, some of it extends the syntax itself.\n\nHence, the expectation of end users to demand new syntax to \"keep up with the joneses\" is satisfied by the perspective shift: There's an endless supply of \"new and modern stuff\" you can get in your daily life quite easily, if that's what you want.\n\nHowever, personally that's becoming one of the *downfalls* of CPAN, the language you use to describe your programs has a growing tendency to be changed at the whims of other people, akin to one of those assholes who reads something you write and intentionally use different interpretations of words than you clearly meant, and that everyone agreed upon at the time, ... and then tries to convince people that their interpretation is the right one, what *you* meant when you wrote it is irrelevant, \"here's what you should have meant when you wrote that\". Nonsense.\n\nThough I'd rather have that sort of shenanigans on CPAN than in Perl itself. This idea that people have to stuff breaking changes in the core language to \"keep up with the times\" is toxic to a functioning ecosystem.", "id": "e4ynbjs", "replies": [{"body": "I know what CPAN is. I have a PAUSE account and you can find my modules on there. It's just stupid. People use Perl on Windows. What do they say, \n\n> Windows is an IDE, and Perl a VM, and CPAN is my language\n\nWhat if they learn Javascript\n\n> Windows is an IDE, and JavaScript a VM, and NPM is my language\n\nCan you ask the ITT professor where [TurboFan](https://github.com/v8/v8/wiki/TurboFan) fits into this analogy?", "id": "e4z9ybk", "replies": [{"body": "No, because windows installs don't contain *anything* that remotely approximates a development toolkit, you have to install  all manually, and then, it's all typically \"here's a box of gui tools that will give you opinions on programming\".", "id": "e4zv7iu", "replies": [{"body": "So is Linux an IDE? And is Ubuntu a Linux? Because mine didn't come with anything I would say approximates a development toolkit.", "id": "e501eu7", "replies": [{"body": "They at very least came with a better source code editor than fucking notepad ;)\n\nEdit: Also, for the record, I don't really consider Ubuntu \"a linux\" much, even though it *kinda* is, its more a \"windows with linux flavours\" for me. Its not really caring about Unix philosophy, and cares more about being a mushy piece of user friendly garbage, like windows.\n\nAlso edit: But ubuntu did at least come with 1 language you could consider a A\"Programming Language\",  be it Python, Perl, or Bash. Windows until very recently had nothing but cmd.exe, which really isn't fit to be called a programming language. Powershell *maybe*, but this is evidence that microsoft are trying to tempt Linux devs to windows by being better as a development platform, and in a roundabout way, proving my point.", "id": "e50y115", "replies": [{"body": "Ubuntu has Perl and python. Windows has PowerShell.\n\nNot sure how Ubuntu isn't a Linux. This is pretty much determined by the kernel -- that's Linux. Also, the Unix Philosophy argument =( seriously does anyone not use SystemD? Why isn't that argument dead yet?", "id": "e511vhj", "replies": []}]}]}]}]}]}]}]}, {"body": "If we forced everyone to first learn Perl6+Haskell+Smalltalk, we likely wouldn't have any other languages. :)", "id": "e4wkmh3", "replies": []}]}]}, {"body": "Perl certainly has its warts, but after 20+ years of using it I still haven't found anything I like better for whipping up quick little utilities, and it's still pretty much unparalleled for working with text. A huge number of modules available on CPAN is nice too. ", "id": "e4u59p0", "replies": [{"body": "Small scripts, heh. How unfair. In my 20 years Perl career I've seen and worked on a lot of complex apps. When you get to that level Python/Perl differences stop to matter.", "id": "e4vv2lz", "replies": [{"body": "Without any Python experience, I wager that `use strict` and more flexible scoping rules still are nice to have in larger applications.", "id": "e4wlcmi", "replies": []}, {"body": "> When you get to that level Python/Perl differences stop to matter.\n\nI would love to know what that means.", "id": "e4wjgn8", "replies": [{"body": "I only meant that when you venture outside of a circle of so called sysadmin perl experts that only use any language for simple throw-away scripts and into a realm of applications that span thousands of classes and millions of lines of code, coding practices start to converge and perl code can be written in a very clear and readable manner.\n", "id": "e4xburp", "replies": [{"body": "Ah, yes, I agree fully. I thought he was talking about \n\n> I like better for whipping up quick little utilities, and it's still pretty much unparalleled for working with text\n\nHe was referencing capabilities and not the ability for others to read/write it.", "id": "e4xo2hj", "replies": [{"body": "He was referencing perl's applicability for quick little utilities and I thought it's unfair to focus solely on that. In any case, these religious wars are meaningless, will not affect the established perception and I should have known better before jumping in.", "id": "e4xvvi2", "replies": []}]}]}]}]}]}, {"body": "\"Hate\" is a strong word. Perl is very useful in some contexts, and not so useful in others. I can't use it at work (we don't have it installed anywhere, otherwise I probably would). But for personal needs I use it a lot: writing text conversion scripts, searching through files, batch rename, image manipulation, etc. But saying \"people hate\" any kind of a tool including Perl language is strange. Can you hate a TV, a PC, a car?.. Maybe. In that sense yes, people may find something that works better than Perl for their particular task and context -- that's fine. But how often do you hear: \"I hate radio with a passion!\". Why? What kind of radio? Since when? What was the reason for this hate?  \n\n\nThe more important (and classical) question is: would you write an air traffic control system in Perl alone? The answer is, you probably could, but why limit all of your choices to a single tool?", "id": "e4vam3x", "replies": [{"body": "Conversations on this topic would be much more civil if everyone shared this perspective.", "id": "e4vmrz3", "replies": []}, {"body": "If the only radio you were ever exposed to was playing really awful music at work, and you never bothered to tune in at home to find out good music played. You could come to hate radio, with the expectation it only ever plays things you find to be awful in taste. That's where the hatred feels come from in your analogy. Its not that people hate tools, they can hate what is built with them, or how they are being used incorrectly (hammering screws, hammering things smooth, hammers made from smaller hammers, hammers all the way down). I hate hammers, they are so awkward to do the most basic DIY tasks, the ones made of smaller hammers are so ugly to look at!", "id": "e4w1ly5", "replies": [{"body": "Yeah, one of my first jobs was to account for ticket stubs in a travel agency. Very boring. And they played same radio station (classic rock) with the same tunes, over and over and over again 40 hr/wk. I hate classic rock for that particular reason. :-) . But that was the only choice for me, and not mine to make (I'm talking about pre-olympic Atlanta).\n\nPerl has a lot of good things about it, one of which is that it cannot be boring by design. :)", "id": "e4w7j9z", "replies": []}, {"body": "Can confirm. However, in my experience, changing station doesn't help. It helps in ultra-short-term, but in the long term, every station seems to become an incessant stream of repetitive garbage.\n\n\"Look, I liked that song yesterday, but hearing it again today, and again tomorrow, sorry, GET SOME MORE MUSIC\".\n\nMainstream pop channels are still playing the hits that were the hits back in fucking January for fucks sake. Every day. Multiple times a day.\n\n`</offtopic spleen venting>`", "id": "e4ynolj", "replies": []}]}]}, {"body": "As far as the regex engine goes, everyone else adopted more or less the same system. Nobody has found a sensible way to handle regexes, but they're too useful to leave out. Implementing /x (where you embed whitespace and comments) is the best idea anyone has had for improving readability, and it's still quite limited. If someone can come up with a better way to represent an (extended) Finite State Machine, they would change the world. Until then, everyone is throwing up their hands and deciding that Perl Compatible Regular Expressions (PCRE) are the best out there.", "id": "e4vx73j", "replies": [{"body": "Perl 6 has implemented /x as the default. In fact you can't switch it off.\n\nBut it's gone waaaay beyond that for improving readability and power. From the perl6.org home page:\n\n    grammar Parser {\n        rule  TOP  { I <love> <lang> }\n        token love { '\u2665' | love }\n        token lang { < Perl Rust Go Python Ruby > }\n    }\n\n    say Parser.parse: 'I \u2665 Perl';\n    # OUTPUT: \uff62I \u2665 Perl\uff63 love => \uff62\u2665\uff63 lang => \uff62Perl\uff63\n\n    say Parser.parse: 'I love Rust';\n    # OUTPUT: \uff62I love Rust\uff63 love => \uff62love\uff63 lang => \uff62Rust\uff63\n\nThe syntax is sweet. The semantics are simple.\n\nIt's worth considering the possibilities because they are significant.\n\nA grammar is a special type of class and a rule (or regex or token) is a special type of method that can interleave with regular methods.\n\nSo is code in a P6 regex targeting an FSM or a turing machine? It can do either, and the weaving is seamless.\n\nWant to extend an existing grammar or override some or all of its rules? Just sub-class it.\n\nThis grammar construct and parsing machinery is built in to the language. \nBecause Perl 6 is written in Perl 6 its grammar is written using a Perl 6 grammar. And because the parsing machinery is built in and exposed to userland code when used to compile P6 itself, user code can modify Perl 6 itself. This is a principled grammar based alternative to lisp syntax macros.\n\nA lot of this is pretty revolutionary.\n\nNow consider that the core grammar/regex engine is independent of full P6 just as PCRE is independent of Perl and think about what that portends.\n\nDiscussing these things certainly isn't /r/learnprogramming level material but one day the consequences will be...", "id": "e55u92n", "replies": []}]}, {"body": "For a long while there was quite a lot of internal self-hatred within the community of people who worked in Perl. The wild west of the dot com boom played loose and fast with the syntax and semantics of any code produced. When the bubble popped the remaining Perl devs were actual software engineers, rather than cowboys trying to turn a web company around in a weekend with no real understanding. Its arguably a strength of the language this behaviour was actually enabled. But it did leave a legacy of systemic global technical debt in the world. I'd say this is the root cause of a lot of the hatred, both directly and indirectly. \n\nThe knock on was Perl 5 went through quite a large renaissance leading up to 2010 with the publication of things like the book \"Modern Perl\" giving the post 90/00s line-noise cleanup movement a name. The issue is a very large majority of interest post the web had been lost, so this landslide community shift towards testing culture, nicer code, community best practices and other behaviours along the software engineering axis rather than the fair weather hacker, went largely unnoticed by the wider world. \n\nThe other elephant in the room is Perl 6 which was a *radical* from the ground up reimagining of the Perl language, took longer than expected, just to even fully design let alone implement. This left Perl 5 stuck using minor version numbers for quite big language changes, comparable to Python 2>3 level evolution in less time. Internally to the community that didn't matter, since there was no confusion that 5.8 vs 5.16 (now on 5.28) was a huge difference in language functionality and usability. But for someone coming to the language or outside it looked like possible stasis or marginal progress. Worse is OS packaging efforts might ignore \"minor\" version changes assuming it wasn't important to keep them up to date. \n\nEven to this day there is quite a large drift in what version of Perl 5 to expect to be deployed. This means using nice new features is a mixed bag of success since you can't be sure a version of perl is even from the same *decade* you are programming in. Even though I know how to write and prefer the cool new features in Perl 5, Im prohibited from really using any of them. Almost entirely because maintainers of Linux distros or macOS refuse to update the version of Perl 5 deployed as standard. \n\nFor example macOS High Sierra (released 2017) runs perl 5.18 as standard that was released in 2013! Python 2.7.10 the macOS system python was released 2015. For an example of how annoying this is, subroutine signatures were introduced in a 2014 version of Perl 5, so you can't use them with the default Mac perl installation. But you should have been able to if Apple had kept up to the same degree as the Python base version! So Perl programmers are forced to use a version of their language that is from half the lifetime of node.js ago (at best). Despite innovation of the language happening timely on a yearly release cycle for the last 8 years.\n\nMarketing to correct this has been happening more now there's a lot of things happening around Perl 5 and Perl 6 core development. But its still kind of confusing to someone totally out of the loop. Ultimately the hatred has been initially learned, about 15 years ago, and then fuelled by a reasonable amount of confusion and repeated memes from ignorance from a lot of people who either left when Perl 5 was a hot mess of legacy garbage, or people who have never learned any languages like Perl (shell/awk for example) who find it super quirky and unreadable given languages they already know, especially as none of us can really write the super nice modern syntax because of installed versions being at least 4 years old and usually over a decade out of date.", "id": "e4w0rc9", "replies": []}, {"body": "I guess it's mostly because of ignorance. It seems people think that if you *can* write software in a difficult-to-understand manner, then you *have* to do so. The hate shows up when that person's shoddy work has to be picked up by someone else.\n\nIt's quite easy to write perfectly easy-to-understand and efficient code in Perl, but it seems that this requires a little more cognitive effort than most dabblers are willing to spend. The result is of course a predictable difficult-to-understand mess, and instead of placing the blame on the tool wielder, they place it on the tool. *shrug*\n\nPerl comes with a lot of freedom out-of-the-box, and enough rope to both hang yourself, build a chainsaw from the rest of the rope and then proceed to cut off your foot with it. So you might say Perl isn't a kid's toy, and requires that the developer assumes a certain amount of responsibility for the end product \u2013 perhaps more than with many other comparable languages.\n\nThe up-side of this, is that it's blindingly obvious to see if someone is a bad programmer with Perl; Moreso than with languages that allow to mask incompetence behind a strict syntax.\n\nIt's comparable to the concept \"freedom of speech\" - you *want* people to be free to say anything, because this helps the rest of us identify the cranks and the newbs among us, and react appropriately. :)", "id": "e4vce93", "replies": []}, {"body": "\\> What's the source of all of the hatred?\n\nI think a big part of it is just perception.  People on the Internet like to shit on things.  When you see the same sorts of blather more than a few times, it's easy to think that \"everyone\" thinks that.  It's also, unfortunately, easy to start believing them as well.", "id": "e4wds0v", "replies": []}, {"body": "People hate perl because of a years long smear campaign--  many members of the computer science intelligensia were personally offended that that guy Larry Wall had the nerve to do things differently from them, and *even worse* Larry Wall had the nerve to give talks suggesting that the CS in-crowd actually didn't know that much about what they were doing.  \n\nAgainst this, the evident fact that perl was in fact useful for many things -- and the perl community had come up with many approaches that were promptly imitated by other programming communities -- counted for very little.  No one who was any one wanted to say they programmed in (*sniff*) perl, and they quickly switched to other languages (including many rather perl-like ones like Ruby).  \n\nYou can talk about sigils and complain about the readability of regular expressions, or the scariness of it's type handling, or the inconsistencies in this or that corner case, but that fact remains that these do not actually matter all *that* much (evidence: web 1.0, the human genome project, etc).   Programmers love to pretend that they're highly rational people making decisions for practical reasons, no matter how much evidence accumulates to the contrary that they're as faddish as a bunch of teenagers.  \n\nAs a friend of mine put it recently \"One of the main factors in choosing a programming language is social signalling.\" \n", "id": "e4wgqx0", "replies": []}, {"body": "I think that a lot of the hatred comes from the idea that perl reads like 'line noise'... for those of you who haven't had the joy of working on a terminal emulator over a modem without error correction, line noise causes bits in ascii characters to get flipped, so you get all sorts of interesting stuff on the screen. Perl can be very terse and it's possible to write perl where most of what shows on the screen is punctuation characters. \n\nAt one time (many many years ago) this style was seen as very powerful, and very expressive if you actually knew the language well. This fell out of favor in the perl community about 20 years ago.\n\nI think that my issues with perl come from its flexibility... I work in a code base that consists of about 300K lines of perl... and there are some places in the code where perl has allowed coders to write code that 'just worked' and didn't require too many hard design decisions. The code *isn't* line noise, and it does work in normal operation, but things get weird in edge conditions. Essentially, the problem with a language that lets you do anything is that it's really easy to write code that does the right thing most of the time, but then leaves an infinite realm of undefined behavior that everybody ignores because \"who would ever want to do that?\". Seeing code that seems to be playing it fast and loose has become a code smell for me.\n\nI come from old school unix, I *do* love perl -- shell script and perl are the two languages that are hard wired in my muscle memory, but I do think that perl has meta-problems with its flexibility -- 20-25 years ago, perl programmers learned that  ultra-terse line-noise style programs were impossible to read, and that style fell out of fashion, but perl still allows you to write under-specced, disorganized code that seems to work most of the time... those looks can be deceiving. ", "id": "e4vgpl9", "replies": []}, {"body": "I have 15 years programming Perl. I also have extensive experience with most scripting and compiled languages. In my opinion, the Perl community poses the biggest challenge, but there are *plenty* of technical challenges too.\n\n* Perl lacks types. There is no good solution to this problem yet. JavaScript has TypeScript. Even PHP7 has \"Scalar Type Declarations\".\n* Perl lacks static-method dispatches. In a system like .NET or Java you can resolve static methods in compile time. This saves the cost of MRO.\n* Perl subs calls are expensive. Not sure what else to say, comparatively Perl function calls are heavy.\n* Somewhat because sub calls are expensive, Perl lacks a decent FP library. There is nothing like Rambda.js for Perl -- even JavaScript beats it.\n* Rx.JS is amazing. It's everywhere and in Javascript from the server, to the client -- even Angular uses it. There is nothing like that close in the Perl world. There is nothing like that to begin with, never mind an ecosystem.\n* Async/Await is wonderful. Sure Perl has it, but let's say someone is using Mojo (the only webserver in perl that I know of that runs in an event loop), what interface do they follow? Yea, that's not fun.\n* Perl5 has its own VM. It's horrendous.\n* Perl5 does not compile to an ASTs. You can never do a good job linting perl code because nothing can parse Perl code except Perl. Python can -- in fact, you can compile Python into Javascript (thanks to transcrypt). And you can transpile the newest features of JS into JS6 for running on the browser.\n* MetaCPAN came way too late to replace search.cpan, but thank god it's here.\n* The Perl community was late too adopt git for useful projects, and cpan still doesn't handle it (afaik). For example, if I fork Catalyst on github can I point my manifest to a Github package? I've actually personally published to CPAN just because I wanted to be able to use dependencies remotely and get patches out for others.\n* No one likes RT.\n* No one likes POD: it's a lost war, time to move to Markdown.\n\nJust so no one thinks I'm shitting on Perl. All things considered I still generally like it more than PHP and Python and Ruby. But, damn Python 3 is pretty impressive, and if PEP 577 happened I would given it my second place. These days I prefer JS.", "id": "e4w9dbe", "replies": [{"body": "Doesn't Python have basically the same type problem, though?", "id": "e4wf58j", "replies": [{"body": "Python certainly has [type hinting](https://docs.python.org/3/library/typing.html), it's a core feature for the past 3 years, and was approved in Sept 2014. It also has emerging things like mypy for static type checking. I don't believe the Python JIT takes advantage of types yet. But it seems likely that it'll happen at some point.\n\nThe Python community isn't fast moving either. I'd say it moves about 3 times faster than the Perl community, which puts it somewhere between the speed of moss and slime.", "id": "e4whxac", "replies": []}]}, {"body": "You have a lot of underinformed hyperbole. Don't exaggerate. There's a difference between \"thing does not exist\" and \"thing exists, but it's not good enough for my taste\".\n\n> I have 15 years programming Perl. I also have extensive experience with most scripting and compiled languages.\n\nMake that \"most popular\" instead, otherwise it can't be possibly true. There are thousands of programming languages!\n\n> Perl lacks types.\n\n* [Perl type support in cperl](http://perl11.org/cperl/perltypes.html)\n* [Type Constraints in Moops](http://p3rl.org/Moops#Type-Constraints)\n\n> There is nothing like Rambda.js for Perl\n\n[Perlude](http://p3rl.org/Perlude)\n\n> There is nothing like [reactive extensions] close in the Perl world. There is nothing like that to begin with, never mind an ecosystem.\n\n[Ryu](http://p3rl.org/Ryu)\n\n> let's say someone is using Mojo [\u2026], what interface do they follow?\n\nMojo::Promise \u2192 Mojo::Promise::Role::Futurify \u2192 Future::AsyncAwait\n\n> the only webserver in perl that I know of that runs in an event loop\n\nThere are several, [trawl through Plack::Handler:: namespace](https://metacpan.org/search?size=50&q=event+Plack%3A%3AHandler%3A%3A).\n\n> Perl5 does not compile to an ASTs.\n\nIt does compile to an optree, which is the same in effect. Run any program with `-MO=Concise` or `-MO=Terse` to see the tree.\n\n> You can never do a good job linting perl code\n\n[perlcritic](http://p3rl.org/perlcritic) works for the vast majority of real code. It's better than good.\n\n> nothing can parse Perl code except Perl\n\nIn theory, yes. In practice, external tooling ([PPI](http://p3rl.org/PPI), [PPR](http://p3rl.org/PPR)) gets the job done well enough.\n\n> you can transpile\n\n[Perlito](https://fglock.github.io/Perlito/perlito/perlito5.html)\n\n> cpan still doesn't handle [git]\n\n[cpanm](http://p3rl.org/cpanm#%28arguments%29) does\n\n> No one likes RT/POD\n\nYou project your own opinion on everyone.", "id": "e4x6fyw", "replies": [{"body": "First, I'm not sure why you try to rebut. My goal was only to show why people dislike Perl and to answer the question. Now I'm forced to answer your rebuttal. Technology problems can be solved, but when pointing out those problems comprehensively is greeted with this kind of dismissal, the community rots **from the inside**.\n\n* Types\n  * Right, `cperl` has types: cperl isn't perl, it's better. It's a fork of Perl.\n  * Yes, perl is turing complete you can implement your own types. I'm the author of numerios types for MooseX::Types. That said, these urn in run time. They're slow. They're also not all that clever. Not sure if any of them support functions. If they do, do they support [covariance and contravarience](https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance) \n* Someone wrote a function library, Perlude, in 2015. It has 8 upvotes. It's used only by [the author](https://metacpan.org/requires/module/Perlude?sort=[[2,1]]).  It was last committed to 3 years ago.\n* Ryu has three upvotes. Its last commit was [10 months ago.](https://github.com/team-at-cpan/Ryu). Nothing uses it, and it's mostly undocumented.\n* `Mojo::Promise::Role::Futurify` that's actually kind of cool! Didn't know about this, and I'll have to look into it. May point out again, not a single `++` on metacpan, no one uses it, and [no activity in 8 months](https://github.com/Grinnz/Mojo-Promise-Role-Futurify). All of that said, kudos. A thin wrapper around an established library to get the job done. I do like async await a lot. It's everywhere in JS, and I wish to see it more in Perl.\n* Webservers in an event loop -- you're actually correct here too. I looked into it. Thanks. I didn't know what Plack did. I don't have enough time to read about Plack and PSGI so I'll step back on this claim too, and even go so far as to acknowledge most major frameworks are using it and it looks nice.\n* An AST isn't an optree. Opcodes can be on a tree, but that has very little to do with AST which, afaik (and, you've gotten me a few times), is specific to static parsing of source.\n* `perlcritic` is better than good because it does so much of what is needed. That doesn't mean it does what I want. In Javsacript I can take AST pass it to my linter and then pass the same to a transpiler. It's nice when you can break things (like yanking smartmatch, pseudohashes, or other faculties) and then simply dynamically rewrite that code to new native constructs or use a polyfill. Perl is simply not there.\n* Yes, you can *try* to transpile perl, but you can only ever try because the language grammar can be modified during compilation. This is problematic for *sooo* many things. Take for instance PostgreSQL. Technically Perl is \"safe\", but it shouldn't be. [The reason is because you can *never* safely compile arbitrary perl.](https://stackoverflow.com/a/49963988/124486)\n* `cpanm` sounds awesome then. I hope it becomes core.\n* Projecting my own opinion? Yeah, I guess I do. How can we falsify my opinion? Markdown is supported by github, stackoverflow, reddit, which we're both using here. It's also supported by every major language (including Perl), and is [standardized with CommonMark](https://commonmark.org/). That's a lot of people liking it. Meanwhile, POD is older, has achieved less, and is less-well adopted. Not to mention, write a simple list in pod: (a) you have to encode the spaces you're mixing formatting with markup thanks to `indentlevel` (b) if it's numbered you have to maintain the correct numbering. I never met anyone who didn't dislike POD. It's relatively easy, and there is a gigantic legacy concern; but, it's not the way things are done and the more modern alternative is all around better (imho).", "id": "e4xt8ju", "replies": [{"body": "* I'm glad you think the Futurify role is neat. I find it useful for a lot of things too as a heavy user of both Mojo and Futures. It has no activity in 8 months because it hasn't needed any changes.\n* mst has started attempting to write a transpiling mechanism: https://metacpan.org/pod/Babble\n* Markdown has a critical flaw when used for perldocs: it has no mechanism to indicate a link to a perl module (understandably) or heading within that module that is independent of the renderer (esp. within the same page). For example, say you want to link to a `### some function!` somewhere in the current document. In POD you write `L</some function!>`; in markdown you write `[some function!](#some-function)` and hope that whatever renderer is rendering your page decided to create that anchor the same way. This is why I've been forced to use .pod even on Github (not that I mind, personally). POD was created for perldocs and is only used for perldocs, so I think it's a bit tautological to say it's less popular than markdown.", "id": "e4xuhqb", "replies": [{"body": "* I wish the shadowcat kids the best of luck [writing a transpiler around an 1,800 line regex that \"doesn't parse but recognizes\" Perl.](https://metacpan.org/source/DCONWAY/PPR-0.000021/lib/PPR/X.pm) I wouldn't trust that in a million years, it's theoretically impossible but they may make it acceptable and useful, like PerlCritic. I guess at least the demon beast regex was crafted by the guy who forged the book on regexes. Meanwhile though, in the Node World I imagine over 50% of the code is transpiled.\n* On Markdown. Yep, you're correct. Honestly, I didn't know that rendering wasn't specified by Commonmark. I've never seen a reference implementation that didn't generate a proper id tag based on the lowercasing and `s/ /_/` of the title. That said, the only thing I know that parses POD that isn't Perldoc or Github is metacpan, so you're talking about having known support for three rendering engines, where as with md rendering you're talking about de facto support most everywhere.", "id": "e4xwwd2", "replies": [{"body": "> That said, the only thing I know that parses POD that isn't Perldoc or Github is metacpan, so you're talking about having known support for three rendering engines, where as with md rendering you're talking about de facto support most everywhere.\n\nIt is a very different task for sure. But the main difference is that in POD it's up to the renderer to generate *both* the link and the anchor, so by default they will match (it's Pod::Simple::XHTML that does this for most sites now, by the way, but there are other options) - whereas Markdown only generates the anchor from your heading, and unfortunately has no specification for a \"link to heading\".", "id": "e4xx420", "replies": []}, {"body": "The tricky parts is trying to work out what the Markdown engine will do with non-alphanumeric characters. Some will strip, some will substitute. And *which* characters they strip/substitute may vary. ( Its a frustrating game of whack-a-mole trying to work out how a rendering engine you don't have local ability to replicate will pan out )\n\nPod has the benefit that you can use the exact same characters in both the link, and its destination, and the rendering engine can be relied upon to convert both the same way regardless of *how* it does it.", "id": "e4yoobq", "replies": [{"body": "That's not true, afaik. Even `POD::Simple::XHTML` will escape Verbatim paragraphs,\n\n> This method handles the body of text that is marked up to be code. You might for instance override this to plug in a syntax highlighter. **The base implementation just escapes the text.**\n\nWithout it, you'd have XSS attacks, this may actually violate the pod on perlpod, because it says explicitly,\n\n> **Verbatim paragraphs are usually used for presenting a codeblock or other text which does not require any special parsing or formatting**, and which shouldn't be wrapped.\n\nAlas no one really uses pod outside of perl, so no one really cares\n\n", "id": "e4zabzn", "replies": [{"body": "I believe he was talking specifically about links and anchors.", "id": "e4zjhan", "replies": []}, {"body": "I've actually found a few opensource projects that don't use Perl, but use pod because it's a more convenient source format than hand editing manpages, and so, they use pod + pod2man as their documentation pipeline", "id": "e4zvie2", "replies": [{"body": "*\"You can make a dog house out of anything\"*", "id": "e50wy3c", "replies": [{"body": "You just said \"alas, noone really uses pod outside of Perl\", ... so I gave a counter point. Now you're changing the goal post.", "id": "e50yibc", "replies": []}]}]}]}]}]}]}]}]}]}, {"body": "Perl was originally intended to replace shell scripts on UNIX.  It's got built-in features that act like awk, for instance, and the regular expressions are a lot like sed.\n\nIf you are an old school UNIX scripter, then Perl's great; it's pretty much everywhere on UNIX and has been for a while, and it can replace shell scripts with something a lot more coherent and functional.  Everything is text on UNIX, and Perl is probably the best text processing language out there.\n\nThe downside?  UNIX scripting is extremely weird from a non-UNIX programmer's point of view, and Perl inherits a lot of that.  The current generation didn't grow up at the console typing out commands - they grew up in a GUI and see the computer differently than the old UNIX guys (like me) do.  So they look at Perl and see all the strangeness and are repelled.  Sigils?  Line-by-line processing?  Excessive regex use?  That's not the modern way.\n\nSome of the bad things people say about it are true; for instance, it's easier to write ugly code in Perl than, say, Python.  The TMTOWTDI (there's more than one way to do it) philosophy means that there's not really such a thing as \"idiomatic\" Perl, meaning that it can be hard reading Perl written in a different style.  But it's also easy to write beautiful Perl code.  It just takes more effort.\n\nPerl became popular as a backend web language back in the day because:\n\na. Most webservers ran UNIX\n\nb. Perl was available on those servers, often installed as part of the base system\n\nc. There weren't any web-specific languages at the time\\*\\* (vbscript was being used in the Microsoft world at the time, but it wasn't really a web language, and Microsoft wasn't about to port it to UNIX, not that anyone would have used it\\*)\n\nd. CPAN (Perl's module repository) rapidly filled with web-related modules that made web development easy\n\nAs soon as PHP became powerful enough to be used seriously, it ate Perl's lunch as a web language.  Ruby on Rails joined in on the picnic.\n\nTL;DR Perl is a sysadmin's scripting language.  If you're not a UNIX/Linux sysadmin, and you aren't already familiar with shell scripting, then you'll probably think it's strange.  Strangeness breeds contempt.\n\n\\*Actually, someone made an ASP module for Apache so you could run vbscript (and jscript, I believe) on Apache.  I never heard of it getting much use, though.\n\n\\*\\*Well, there was ColdFusion, but it cost money.", "id": "e4v8l5d", "replies": [{"body": "> Sigils? Line-by-line processing? Excessive regex use? That's not the modern way.\n\nAll of which are also the case on PHP, so it's odd to bring that up as the modern alternative.\n\nWhat PHP brought is that its integration with Apache is a little dumber. With mod_perl, there's little separation between different apps, which made it unsuitable for running on shared hosting environments of the late 90s/early 2000s. Not a big deal with today's virtual hosting, but it was then. With mod_php, it's a straight interpreter embedded in the web server, without the deeper APIs. You give up flexibility (mod_perl has access to practically everything a C module does), but you don't have this overlapping hosting problem.\n\nAs you say, Ruby on Rails came along and showed everyone how it's supposed to be done. IMHO, all web frameworks before then were half measures. Tons of other languages took on a similar approach, including Perl (which has 2 major platforms for that, Dancer and Mojo).\n\nEdit: also, what do you mean by line-by-line processing? If you're thinking of the compiler taking a line, parsing it, and executing it before going to the next line, then that's not how Perl works (don't think it's how PHP works, either). Perl compiles all the code into an AST. It doesn't output bytecode (which is the more modern way), but it doesn't make too much difference in practice.", "id": "e4w0io1", "replies": [{"body": "By \"line-by-line\" I meant filtering (i.e. read a line, do something, spit results out stdout, repeat) and similar UNIX scripting idioms, and Perl's extra support for that sort of processing.  I'm referring to things like $\\_ and the various awk compatibility features, not anything web-related.  Personally, I view Perl's early dominance as a web language a fluke - it was in the right place at the right time.  That time's passed - which is a shame really, because mod\\_perl was really cool.\n\nAnd by \"modern\" I wasn't referring to web development either, but rather modern programming in general.  I probably should have said mainstream, really, because I was thinking of what the colleges are pumping into CS students these days (Java, C#, Python, etc., all with a heavy emphasis on OO).  Show your average CS undergrad Perl code and they'll just be confused and go find something else to do.\n\nRegarding PHP vs. Perl, I don't really think it's horribly useful to compare the two - mostly for the reasons you stated.  As a web language, they're only superficially similar.  As a general purpose scripting language, PHP has little to offer against Perl (except a more conventional OO system, if that's what you want in a scripting language).", "id": "e4wdz5o", "replies": [{"body": "> That time's passed - which is a shame really, because mod_perl was really cool.\n\nIt's still really cool, if what you're looking for is a way to modify the Apache request cycle using an embedded scripting interpreter. It never was a very good idea for Perl web applications, but FastCGI implementations are quirky and we didn't have anything better other than Catalyst. Now is a different story.", "id": "e4wl58f", "replies": []}]}, {"body": "I suspect the thing that really helped for PHP is beyond the syntax.\n\n1. That page processing was inherently templatelike, and that a page loaded, ran, and exited, preserving no implicit state, not needing any sort of looping flow control handling dispatch, etc, kept the conceptual model small enough that people who have almost no programming experience could make do.\n\n2. That shared hosting providers monopolized on #1 and relied on the whole \"you can keep this pump operated with no access other than FTP\" was also huge, because most people had no background to understand other file transfer protocols, and their understanding of \"what is a terminal\" was pretty much zero and so SSH was *well* out of the picture.\n\nIME, to do anything serious with Perl on some webserver, you need *slightly* more advanced hosting requirements, and you need *slightly* more competent (read: pricey) hosting options, and usually, a *slightly* more advanced understanding of a \"dispatch loop\" oriented program.\n\nThese problems are so much less bad than they were back then, but they're still quite prevalent in my experience. ( Especially for people who refuse to pay the higher prices for decent hosting )", "id": "e4ynxyt", "replies": []}, {"body": "mod_perl has always been a mechanism for writing apache extensions.  This made it possible but entirely unsuitable to use as a persistent interpreter for applications.  mod_perl was the right solution to the wrong problem.  mod_php was the wrong solution to the right problem.  These days with reverse proxies, uwsgi and proper application abstraction frameworks, the whole point is moot anyway.  Php is essentially a dumbed down, domain specific, pragmatic perl with some really bad design decisions they're slowly mitigating.", "id": "e55hgjj", "replies": []}]}]}, {"body": "I have two big problems with it:\n\n1. It is extremely easy and tempting to write unbelievably terse, inscrutable statements with it. The Perl community has historically viewed these abominations as clever and elegant. The idiom of default variables is particularly terrible.\n\n2. References are stupid and are completely obviated by Python's much nicer handling of passing arguments to functions.", "id": "e4ty454", "replies": [{"body": "Since May 2014 you can use function signatures of the form:\n      \n      sub function($argument1, $argument2='default_value') {\n      }\n\nbut even without syntax sugar the older style is hardly crazy, you can just consider the signature as being more explicit over several lines:\n\n      sub function {\n         my ($argument1, $argument2) = @_;\n         $argument2 //='default_value';\n      }\n\nI'd personally consider any Perl code making heavy use of implicit default variables beyond something *very* idiomatic and local in lines of code, as really bad Perl code. Every other Perl programmer I've worked with professionally would say the same. The issue is that you /can/ write code like that. It has its place too, lots of code in the world belongs to the category of throw away quick dirty use once scripts. Perl lets you do that and serious programming, that is a strength, so long as you aren't lazy enough to let one world bleed into the other. Unfortunately the 90s and early 00s didn't see much restraint and thought going into code that crept into long term production use.", "id": "e4vx9v1", "replies": []}, {"body": "For clarity of those learning programming...\n\n\\----\n\nThe idiom of default variables is a programming language analog to the English notion of [pronouns](https://en.wikipedia.org/wiki/Pronoun).\n\nConsider this Perl 6 code:\n\n    with $name {\n        .log;\n        .say;\n    }\n\nThe `.log` and `.say` are method (function) calls on \"it\" or \"the topic\". In this case \"it\" is `$name`.\n\nArguably Perl 6 is a completely different language but it and many other programming languages use this pronoun approach. Clearly, some folk think it's always terrible.\n\nI think, if it's used appropriately, it's lovely. Or, to emphasize the contrast, if the pronoun approach is not used when appropriate, I miss the pronoun approach.\n\n\\----\n\nReferences are just like they are in [English](https://en.wikipedia.org/wiki/Reference) \\-- one thing refers to another. They are a type safe higher level language equivalent to pointers in C.\n\nI agree with POGtastic that Python does a much nicer job than Perl 5 in how it presents (or rather hides) references.", "id": "e4vmjkm", "replies": [{"body": "Once you master references, you kinda miss them when you move to other languages like JS or Python.\n\nI have a tendency to stop remembering in which cases variables share referencing when referencing is implicit, and I end up writing extra stupid code to defend against the possibility what I think *could* happen can't.\n\nI get the syntax/approach is a bit inconvenient for some, but its a good tradeoff for a lot of power if you ask me.", "id": "e4ynl0d", "replies": [{"body": "The power you're talking about being less bugs, right?\n\nWould you be willing to share some as simple code as you can come up with in Perl and Python that shows the issue? TIA if you have time.", "id": "e50f7xv", "replies": [{"body": "Power being to do what you want whenever you want, instead of letting the language decide what the usecase is.\n\neg: The ability to pass an argument explicitly by reference instead of copying the value, has uses. It can also be *misused*, but that's the price you pay for power.", "id": "e50yhfn", "replies": []}]}]}]}]}, {"body": "Very simple explanation. 90% of everything in this world is crud, including opinions on any given subject.", "id": "e4vusug", "replies": []}, {"body": "Perl is often called a \"write-only language\". It's not that writing scripts in Perl is bad, it's that maintaining them- going back months later, or as a different developer to build on it or fix bugs- is difficult- because the weak typing and abundance of regular expressions makes it hard to read.\n\nThat's why Perl is popular for writing small system administration tools (although Python has at least partially displaced it in the last decade), but not for writing large programs.", "id": "e4txwbq", "replies": [{"body": "**TL;DR** To me your comment and the upvotes it garnered for a while demonstrate the mechanisms of Perl hatred in action.\n\nYour comment feels sincere and balanced. But it sounds like you've never read well written Perl code.\n\nYou must have seen well written Perl code. So I assume you felt that what you saw must have been the exception rather than the rule. But that would suggest you don't know what's out there because there's a *ton* of very well written code.\n\nSo your comment, which is fairly clear and simple, is also profoundly misleading. In combination with its upvotes it arguably demonstrates why Perl is so hated.\n\n>\"For every complex problem there is an answer that is clear, simple, and wrong.\" - H. L. Mencken\n\nPerhaps your answer is just wrong in an innocent way or even the right way (by demonstrating the problem), but it still seems wrong to me.\n\nPerl can be and generally is used by the many who love it to write beautiful, readable, maintainable code.\n\nThe same sort of thing is true for almost any programming language.\n\nConversely, even the popular Python or somewhat respected Haskell can be and often are used to write atrocious code.\n\nA language makes things possible. A writer decides what use to make of that range of possibilities.\n\nIn regard to the specific reasons you suggested some people find Perl hard to read:\n\n* The phrase \"weak typing\" is an unfortunate phrase to use loosely in this /r/learnprogramming context. To a novice it implies something that is inherently a bad thing. In many scenarios it's a well respected significant improvement over inappropriately rigid strong typing. See [the wikipedia explanation](https://en.wikipedia.org/wiki/Strong_and_weak_typing#Implicit_type_conversions_and_%22type_punning%22) for some discussion. In the meantime, the meaning of the code `a + b` is a great example for you and readers to consider.\n* That said, while imo there are good things to be said about Perl 5's approach to typing, there are bad things to be said too, with Perl 5's approach to the type analog of [allomorphs](https://en.wikipedia.org/wiki/Allomorph) being perhaps the thorniest. Larry Wall is the Perl designer. See Perl 6 for his dramatic response on the type system front. While he kept the super easy way one can write easy things without paying attention to types, the Perl 6 design also allows a writer to selectively annotate as many individual variables/values/expressions/arguments as they desire. This way they can use any desired combination of formally type-safe type punning (weak typing) *and* strong typing.\n* Large bodies of Perl code contain *zero* regexes. When regexes are written, they are written because the writers wanted to write them. For some types of problem they are spectacularly useful, far simpler than any other option. This is why most languages have incorporated Perl 5 style regular expressions. See, for example, [PCRE](https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions) and [Python's re module](https://docs.python.org/3/library/re.html?highlight=re#module-re). Perl has remained a worldwide leader in developing regex power.\n* That said, while there are good things to be said about Perl 5's regexes, there are bad things to be said too, including both their cryptic syntax and a profound lack of power even if they're the most powerful in the world of regexing not including Perl 6. The response to regex limitations in Perl 6 is even more dramatic than the type system response while also cleaning up the syntax.\n\nFinally, I think Perl 5 isn't a rational choice for new large systems (ones you know will run to more than a million lines of code). Imo it looks likely to have weaknesses at that scale -- but note that there are still multi million lines of code systems running multi billion dollar revenue per year businesses.\n\nBut, again, consider the new programming language Perl 6. While no one will be writing such large systems in Perl 6 any time soon if ever, given that it's too new and that it is currently hated as much as Perl 5 because it has the word \"Perl\" in it, Perl 6 will likely add decades of life to CPAN's 25,000 or so existing Perl packages for use in large projects.", "id": "e4vjbhf", "replies": []}, {"body": "FWIW, [Perl 6](https://perl6.org) has replaced the weak typing with gradual typing, and turned the regular expressions into readable, subclassable and maintainable grammars capable of parsing the Perl 6 language itself.", "id": "e4uzmkw", "replies": []}, {"body": ">abundance of regular expressions makes it hard to read.\n\nIf you don't like the regexes, then don't use them.  You're not required to. ", "id": "e4wdo91", "replies": []}, {"body": "It may be worth mentioning that the \"write-only language\" claim seems to be one repeated predominantly by people who never learnt perl, and their only experience of Perl is:\n\n- Cultural memes from other people who don't know/hate perl\n- Terrible examples of Perl cherry picked to show their horrendous, ( and sometimes those cherry-picks are intentionally obfuscated code )\n\nIn *practice*, the Perl <-> Other language divide is more like the Chinese <-> English language divide: If English and Romanized languages are all you're familiar with, Chinese looks like a bunch of incomprehensible scribbles which are impossible to read.\n\nIn *practice*, there are vast volumes of Perl code that is *entirely undocumented* which Perl practitioners make sense of by literally just reading the source.\n\nSometimes, even Perl code that *has* documentation is read by practitioners by reading the source instead, because the code indicates what the code *actually does*, where the documentation indicates what some developer *thought* or *intended* the code to do *once upon a time*, and this may not be correct, or may have been changed since the documentation was last updated.\n\nI was once a fool who repeated this phrasing about \"write only language\", because I had no relevant experience to the contrary, and all my peers who similarly had no experience kept saying that.\n\nAnd now, I'm in a weird place because Perl is one of the only languages I'm willing to work with anymore.", "id": "e4yoejm", "replies": []}, {"body": "Python is just a lot better overall! And I mainly use C# myself, and respect it! I would write software in it (if I can get an IDE that has solid Indenting support, because Python and Indents... I have had issues in the past.)", "id": "e4u0b00", "replies": [{"body": "Well, yes, a C# programmer would likely prefer Python over Perl.\n\nIf you mostly wrote scripting code on UNIX using the traditional tools (sh, sed, awk, etc.), you'd probably prefer Perl.  But hey, maybe not - I mean, there are people out there that genuinely enjoy programming in COBOL, so who knows?\n\nIt's all down to what you're used to.  As an old UNIX guy, I love Perl, respect Python (although I rarely use it - I mean, I already have Perl...), and detest shove-the-OO-down-your-throat languages like Java and C#.  But that's just me, and honestly neither of our opinions are worth much more than the text on this page.", "id": "e4wf2x1", "replies": []}]}]}, {"body": "Some reasons people hate perl with a little commentary:\n\n* Much of the discipline of  computer science is inspired by theoretical linguistics.  Perl is explicitly inspired by practical linguistics.  This means that most normal programming languages have quite a different frame of reference to perl and so perl seems quite alien and wrong from an academic point of view.\n\n* Perl's biggest strength is also its biggest weakness: it's extermely flexible.  For example, Perl's OO model was stolen from Python.  However while Python's OO model is just an OO model (i.e. there's one way to do it), Perl's OO model is a toolkit for building OO models.\n\n* Perl has a single implementation, and no AST that's not bound to the implementation.  This means that making multiple independent implementations of the interpreter is hard.  \n\n* Perl is a rich and deep language.  Easy to start, hard to learn thoroughly (a bit like the English language).  In an industry driven by fashion, needing such a depth of knowledge is a disadvantage.  However, perl scales from the smallest use case (thow away one liner) to the large use case (large complex applications) very well.  There's no normal activity can do in any other dynamic language that I can't do in perl.\n\n* Lots of horrible legacy code kicking around and lots of people's bad memories of now dead or undead bad legacy code.\n\n\n", "id": "e55h64z", "replies": []}, {"body": "There's a sub-category of Perl hatred which is Perl **6** hatred.\n\n(Some of this is internal to the Perl world. There are folk who love Perl 5 but who hate on Perl 6. But that's probably not of interest to folk wondering about Perl hatred in general and reading /r/learnprogramming.)\n\nThe rest of this comment tries to show some rational reasons to hate or at least dislike Perl 6. Or, conversely, to see past the hatred and be open to the possibility of not disliking but rather liking or loving Perl 6. YMMV.\n\n\\----\n\nSome extremely simple code in Python 3:\n\n    value = 1\n    \n    def routine (value):\n        value = 2\n        print (value)\n    \n    routine (value)    # 2\n    \n    print (value)      # 1\n\nThe same in Perl 6:\n\n    my $value = 1;\n    \n    sub routine ($value is copy) {\n      $value = 2;\n      print $value\n    }\n    \n    routine $value;    # 2\n    \n    print $value;      # 1\n\nPerl 6 looks more verbose and complex. Why? Is it worth it? For many folk who don't understand why Perls have their extra verbosity and complexity its different look is reason enough for hate.\n\nThe rest of this comment talks a little about why Perl 6 has the extra complexity shown above. It's for the reader to decide whether it's worth it. (Though you'd probably have to do more than read this comment to make an informed call. You'd probably need to write code for a few weeks/months in Python and in Perl 6 to really appreciate the long-term impact of the tradeoffs.)\n\nThe `my` explicitly declares `$value`.\n\nWithout such a declaration a compiler can't tell the difference between a `value = 1` statement that simultaneously introduces a new identifier *and* assigns to it and one that merely assigns to an existing identifier introduced earlier in the code. That can bite you in the ass.\n\nSo Perl 6 requires a declarator. (You can switch this strictness off, eg. for one liners, but it's the default. Perl 6 has different declarators for different [scopes](https://en.wikipedia.org/wiki/Scope_(computer_science)). This increases coding flexibility and aids at-a-glance comprehension of code.)\n\nThe identifier `$value` starts with a `$`.\n\nThis marks it as an identifier to be used as a noun. Python doesn't mark nouns which keeps it simpler to learn and less symbol heavy to read but misses out on several significant advantages of marking nouns, eg eliminating accidental overlaps between function and variable names.\n\nThe first line ends with a `;`.\n\nAn advantage of Python's simple one line, one statement approach is that you avoid having to type semi-colons and see them between statements. But this has many disadvantage, eg ruling out almost all non-trivial one-liners, a big loss when doing things from a command line.\n\nThe `is copy` \"trait\" makes the compiler copy the incoming argument and make it assignable.\n\nIn Perl 6, by default, a routine parameter for a scalar (a single thing) can not be assigned to. This default eliminates a class of bugs. Explicitly adding the trait enriches at-a-glance code comprehension.\n\nIn Perls, as in many languages, code blocks are delimited by `{` and `}`.\n\nPython does away with delimiters by relying on indentation and use of `:` instead. This sharply reduces visual clutter. But it has downsides, eg. cutting and pasting code can non-obviously change the meaning of code.\n\n\\----\n\nThis is a small taste of the difference between Python 3 and Perl 6 but many people are forming opinions of love and hate based on little more than the above sorts of distinctions.\n\nThere are good reasons for the differences. Python focuses on simplicity while delivering a good deal of power. Perl 6 focuses on simplicity while delivering a good deal more power. But if you don't care about the extra power (and why would you if you're a newbie or if you're just not interested?) then the extra symbols all look rather pointless and confusing.", "id": "e561av1", "replies": []}, {"body": "They say if you give a thousand monkeys a thousand typewriters for a thousand years, eventually one will write a Shakespearean sonnet.  The rest will write perl code.", "id": "e4ube8v", "replies": []}, {"body": "It\u2019s ancient, complex, and better programming languages exist.\n\nIt\u2019s the same issue I am having in LISP. It\u2019s so far left field that it\u2019s hard to learn coming from a strong as hell C-Like language background.\n\nTBH, AFAIK, it\u2019s most certainly not a common language. So people have no motivation to learn it.", "id": "e4twzgw", "replies": [{"body": "You'd be surprised how many things use it. A lot of apps you use everyday are written in it (especially if you use Linux or a Mac). \n\n\nA big one would be spamassassin which just about every email security company in the planet uses. \nAlso many companies still rely on it\n\nTesla\n\nBooking.com\n\nCraigslist\n\nDuck duck go\n\nIMDb\n\nYou are right though that is much more common to find tutorials in other languages.\nI used to write some cloud Email security software so that's when I picked up Perl. It's now my go to in most cases. ", "id": "e4v8rfj", "replies": []}, {"body": "See, I am the opposite. I love Perl for its list processing abilities like Lisp has, without forcing you into the \"everything is a list\" paradigm. Little bit of A, little bit of B.\n\nAnd yes it is a common language, a lot of Linux utilities use it to manage system administration even to this day. I was shocked to find out the other day that Ubuntu uses it for user administration, *adduser* is a perl script.\n\nJust because you use it doesn't mean no one else finds utility in it.", "id": "e4w5g6x", "replies": []}, {"body": "Have you looked at [Perl 6](https://perl6.org)?  It's taken a long time to get released, but it's available now and used in production.  And ready to be around for a very long time to come!", "id": "e4uzsn8", "replies": [{"body": "No one uses Perl 6 in production for anything beyond the most minor things.", "id": "e4v1y3n", "replies": []}]}, {"body": "[Speaking of LISP...](http://www.paulgraham.com/avg.html)", "id": "e4v1zig", "replies": []}]}], "title": "Why is Perl so Hated?"}