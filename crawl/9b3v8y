{"url": "https://www.reddit.com/r/learnprogramming/comments/9b3v8y/i_keep_seeing_the_term_modern_c/", "text": "Anyone care to explain what modern c++ is and how it\u2019s different than the traditional way c++ is taught ", "score": 10, "comments": [{"body": "C++ that is based on C++11, C++14, and C++17.", "id": "e5069ne", "replies": []}, {"body": "Well I guess the main things would be:\n\n - use of the Standard Library, rather than write it yourself\n - use of smart pointers, not raw pointers\n - use of auto and ranged-based loops\n - use of move semantics\n - use of lambdas\n - use of templates\n \nAnd so on - I'm sure people can come up with other examples. \n\nThe traditional way C++ is taught is generally a god-awful version of C.", "id": "e506gmx", "replies": []}, {"body": "\"Modern C++\" refers to C++11 and up. \n\nC++11 added a bunch of new features (lambda, move semantics, rvalues, foreach, bunch of constructor stuff, lots of template, constexpr, auto) and was a huge leap away from \"C with classes\".\n\nModern C++ put a more pronounced emphasis on stuff that makes C++ C++, like templates and template metaprogramming, strong typing, RAII, and a ^big hint of functional programming.\n\n*****\n\n> how it\u2019s different than the traditional way c++ is taught \n\nThis is a really hard question, C++ is hard to teach (because it's fucking huge) and I don't think there is a single right way of teaching modern C++.\n\nA good tell that a tutorial or book is not \"modern C++\" is the use of new and delete and owning raw pointers, those have been pretty much replaced with smart pointers (now that we have move semantics) in most cases. \n\n\nIf I had to come up with a \"modern C++\" course, I would probably introduce stuff like string and vector (as well as other std containers and algorithms) very early, then move onto classes, then references, then RAII, then polymorphism and finaly raw pointers. \n\n\n\n ", "id": "e506t8j", "replies": []}, {"body": "C++ is currently controlled by a branch of the International Organization for Standardization (abbreviated ISO; they're a organization established by the United Nations). Since around 2011, ISOCPP has basically been like Oprah. Their general policy has been \"You get a language feature! And you get a language feature! And *you* get a language feature!\" And so on. They've added a ton of stuff to C++, with big releases coming out every three years. \n\nC++11 (for 2011) added move semantics (to indicate that ownership of an object is being transferred, thereby avoiding unnecessary copying without much fuss), automatic type deduction of variables, and lambdas, uniform initialization, as well as additions to the standard library. They also improved the way templates worked, eliminating some of their old failings.\n\nIn 2014, C++14 came out with even more new features. Since then, lambdas can now store an internal state, functions could be declared as \"auto\" (so the compiler deduces the return type automatically), and you can have global variables that are templated (so you can habe Pi<float>, which gets Pi as a float, and also Pi<double> and Pi<long double>). They also added a bunch of stuff to the standarf library.\n\nIn 2017, C++17 came out, bringing with it if statements that control how a program is compiled based on compile-time checks, along with structured binding (which allows you to break a struct into its members without even knowing what those members are calles), a filesystem library, and additional improvements to the standard library to provide better support for parallelization. \n\nStructured binding example:\n\n    struct Point { double x_cor, y_cor; };\n    \n    Point p;\n    \\\\ code\n    auto& [x, y] = p;\n    x = 13; \\\\ sets p.x_cor to 13\n\nIn two years, C++20 will come out with even more great features, like contracts (which help you catch errors at compile time before they become exceptions).\n\nThere are a ton of other features they've added aside from the ones I listed above, but those were just the ones I remember off the top of my head. ", "id": "e50v20s", "replies": []}, {"body": "Modern C++ is just furthering the abomination that is C++. ", "id": "e50f734", "replies": [{"body": "At least it\u2019s performant", "id": "e50odtd", "replies": []}, {"body": "Well at least *we* have \n\n- compile time checks and static typing (unlike Python); \n- true first class function objects (unlike Java); \n- templated classes rather than god-awful virtualized genetics (unlike Java); \n- operator overloading (unlike Java); \n- optional garbage collection, along with smart pointers for when GC is too slow (smart pointers delete themselves without garbage collection)\n- a sense of dignity ", "id": "e50vckz", "replies": [{"body": "And one of the biggest specs, and one of the worst compile times and a thousand ways to shoot yourself in the foot.\n\n", "id": "e50x63r", "replies": [{"body": "Our language specification is only big because it includes the specification for the standard library; if you take out the standard library, then the C++ language specification is around 440 pages (which 350 pages *shorter* than Java's language specification).\n\nCompilation time will improve a lot when the module system is finalized, and right now only the largest programs and libraries have long compilation times. Small programs of a few hundred to a few thousand lines in c++ often compile faster than equivalently sized programs in Java. \n\nAs for shooting yourself in your foot: Most of those are due to backwards compatibility with C, and new language features have made the problem better, not worse.", "id": "e51rrje", "replies": []}]}, {"body": "You also have \n\n* Template system that gets abused harder than a cheap whore\n\n* Stupid inheritance semantics (virtual destructors, virtual inheritance) \n\n* Allowance of low level memory access coupled with high level class objects and smart pointers leading to \n\n* Allowance of reference objects, leading to even more of a confusing mess. \n\nIn terms of real world uses, C++ is generally good if you avoid a lot of bad practices. It results in a higher performance than others and allows for better collaborative coding. I still prefer C over C++ though any day. ", "id": "e51oldg", "replies": []}]}]}], "title": "I keep seeing the term \u201cmodern c++\u201d"}