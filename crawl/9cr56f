{"url": "https://www.reddit.com/r/learnprogramming/comments/9cr56f/determining_undefined_behavior_malloc/", "text": "Is there any way to determine if the size you asked for has been successfully been allocated on the heap?\n\n    int *ptr = (int*)malloc(3);\n    *ptr = 10;\n\nThis should be undefined behaviour, since you are writing 4 bytes to a heap where you asked for 3 bytes. The compiler doesn't give any warnings and if you print out `*ptr`, it does it fine.", "score": 0, "comments": [{"body": "I think [this](https://stackoverflow.com/questions/41822904/why-does-malloc1-work-for-storing-4-byte-integers) question's answers explain it pretty well.", "id": "e5cplxp", "replies": []}, {"body": "Undefined behavior is just that - undefined. There are no specific rules for what will happen in this situation. Happening to appear to work is as completely valid as formatting your disk as far as what will actually happen when you run code with undefined behavior.\n\nAs far as the first question (determine if malloc succeeded), if the returned pointer is null then the allocation failed and you can check errno for the error code. If the pointer is not null, the allocation succeeded.", "id": "e5cue5f", "replies": [{"body": ">If the pointer is not null, the allocation succeeded.\n\nthat's correct; memory will be allocated until there's not enough space but here you are writing more bytes than you allocated. What's the worst thing that could happen?", "id": "e5cum9b", "replies": [{"body": "Well, just to harp on it a bit more, since it's undefined behavior, literally anything that it is possible for a computer to do could happen ([including time travel](https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633)).\n\nBut in practice, I'd expect that you'd either corrupt another variable's memory, causing a terrible to debug bug, or you might cross into an unmapped range, which would cause a segfault, or you'd get lucky and nothing bad happens.", "id": "e5cv68q", "replies": []}]}]}, {"body": "You don't get warnings for undefined behaviour. You can use a validator program like Valgrind to watch out for errors where you're reading/writing to memory you don't own. But otherwise, the program may or may not crash when you invoke undefined behaviour.", "id": "e5cvvpx", "replies": []}, {"body": "You have a couple of different questions here. First, yes, you can determine if the size you allocated was successfully allocated on the heap based on whether or not `malloc()` returns `NULL`. It didn't, so you got at least three bytes. That last bit is important. C doesn't say whether or not you got *exactly* three bytes. You almost certainly got more. Almost certainly enough to store an integer.\n\nIs this undefined behavior? TBH, I don't know if it's undefined or unspecified, but it's certainly \"wrong\". However, the C language as a general rule will let you do wrong stuff. Sometimes it will warn you (when it can), but the main responsibility is on you to not do the wrong stuff. That's what you get for using C. Other languages will check to make sure you don't write or read beyond the end of allocated memory, but C is not your mother. C doesn't care. ", "id": "e5cwy8h", "replies": [{"body": "Fair enough. I am not sure if using smart pointers in C++ would take care of it but I reckon C++ is preferred over C when it comes to things like memory management, which can be a pain in the neck at times when you have to do it manually.", "id": "e5cxukq", "replies": [{"body": "Smart pointers will take care of *some* things, but not generally writing to illegal addresses. A vector type can do that (depending on how you use it and whether you are compiling in debug or release). Memory management is definitely a pain in the neck, which is why garbage collection is so wonderful. Sadly, memory management is only one flavor of resource management and garbage collection doesn't handle this problem in general (which RAII actually tries to do and mostly succeeds).", "id": "e5czcuq", "replies": []}]}]}], "title": "Determining undefined behavior - malloc"}